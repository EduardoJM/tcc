

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Como o modelo faz o uso do bibtex para as referências,
% quando as mesmas são alteradas, quando as citações são
% alteradas, dentre outros casos, é necessário recompilar
% o bibtex. Para isso, siga a ordem de compilação (apenas 
% nos casos citados acima):
%
% (pdf)latex + bibtex + (pdf)latex + (pdf)latex [+ preview]
%
% sendo que o comando [+ preview] é opcional para a 
% visualização do documento.
% No editor TexMaker, as teclas de atalho para os comandos
% acima são:
%
% F6 + F11 + F6 + F6 [+ F7]
%
% Observação: Você pode fazer isso alterando as configurações
%             em "Opções -> Configurar o TexMaker", onde na
%             janela de configuração, na barra lateral,
%             selecione Compilar, altere o campo "Comandos
%             de Compilação Rápida" para o segundo (que
%             que parece com os comandos acima) e dê ok.
%             Use a opção "Compilar" do TexMaker agora que
%             a ordem de comandos acima será executada,
%             gerando, assim, as referências.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[
	% -- opções da classe memoir --
	12pt,				% tamanho da fonte
	openright,			% capítulos começam em pág ímpar (insere página vazia caso preciso)
    twoside,			% para impressão em recto e verso. Oposto a oneside
	a4paper,			% tamanho do papel.
	% -- opções da classe abntex2 --
	chapter=TITLE,		% títulos de capítulos convertidos em letras maiúsculas
	%section=TITLE,		% títulos de seções convertidos em letras maiúsculas
	%subsection=TITLE,	% títulos de subseções convertidos em letras maiúsculas
	%subsubsection=TITLE,% títulos de subsubseções convertidos em letras maiúsculas
	% -- opções do pacote babel --
	english,			% idioma adicional para hifenização
	french,				% idioma adicional para hifenização
	spanish,			% idioma adicional para hifenização
	brazil				% o último idioma é o principal do documento
	]{abntex2}

% ---
% Pacotes básicos 
% ---
\usepackage{lmodern}			% Usa a fonte Latin Modern			
\usepackage[T1]{fontenc}		% Selecao de codigos de fonte.
\usepackage[utf8]{inputenc}		% Codificacao do documento (conversão automática dos acentos)
\usepackage{lastpage}			% Usado pela Ficha catalográfica
\usepackage{indentfirst}		% Indenta o primeiro parágrafo de cada seção.
% Pacote para o uso de cores no documento
\usepackage{color}
% Pacote para a inclusão\manipulação de imagens
\usepackage{graphicx}
\usepackage{microtype} 			% para melhorias de justificação
% ---
		
% ---
% Pacotes adicionais, usados apenas no âmbito do Modelo Canônico do abnteX2
% ---
\usepackage{lipsum}				% para geração de dummy text
% ---

% ---
% Pacotes para escrita matemática
% ---
\usepackage{amsmath}

\usepackage{amssymb}	 % qed
\usepackage{amsthm}      % Teoremas

\newenvironment{amatrix}[1]{%
  \left(\begin{array}{@{}*{#1}{c}|c@{}}
}{%
  \end{array}\right)
}

% Cria um novo ambiente para Teorema
\newtheorem{teorema}{Teorema}
% Cria um novo ambiente para Definição
\newtheorem{definicao}{Definição}
% Cria um novo ambiente para Exemplo
\newtheorem{exemplo}{Exemplo}
% Cria um novo ambiente para Lema
\newtheorem{lema}{Lema}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Recria o ambiente para demonstrações
% \begin{proof} [...] \end{proof}
% 			Observação: O ambiente foi recriado para adequação
%						das fontes com o restante do texto
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatletter
\renewenvironment{proof}[1][\proofname]{
	\par\pushQED{\qed}%
	\normalfont \topsep6\p@\@plus6\p@\relax
	\trivlist
	\item\relax
		{\itshape
			#1\@addpunct{.}}\hspace\labelsep\ignorespaces
}{%
	\popQED\endtrivlist\@endpefalse
}
\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Cria o ambiente para solução de exemplos.
% \begin{solution} [...] \end{solution}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatletter
\newenvironment{solution}{
	\begin{proof}[Solução]
}{%
	\end{proof}
}
\makeatother


% Reseta o numerador do ambiente Lema ao fim de todo
% capítulo. Assim, os Lemas serão indexados por capítulo
% e não no documento todo. Por exemplo, no Capítulo 1,
% tem-se, Lema 1.1, Lema 1.2, etc.
\numberwithin{lema}{chapter}
% Mesma função explicada acima para os ambientes de
% teorema, definição, exemplo, figure
\numberwithin{teorema}{chapter}
\numberwithin{definicao}{chapter}
\numberwithin{exemplo}{chapter}
\numberwithin{figure}{chapter}

% Pacotes do Tikz utilizados para desenho
\usepackage{tikz, tkz-euclide, tkz-fct}
\usetikzlibrary{babel}
\usetkzobj{all}

% Pacote para a inclusão de códigos e para gerar
% "Syntax Highlight" (Coloração do Código)
\usepackage{listings}

% Define o nome de marcação para os Blocos de Código
\renewcommand{\lstlistingname}{Código}
% Define o nome de marcação para a Lista de Códigos
\renewcommand{\lstlistlistingname}{Lista de \lstlistingname s}
% Comandos utilizados para a criação e estilização
% da Lista de Códigos
\begingroup\makeatletter
\let\newcounter\@gobble\let\setcounter\@gobbletwo
	\globaldefs\@ne \let\c@loldepth\@ne
	\newlistof{listings}{lol}{\lstlistlistingname}
	\newlistentry{lstlisting}{lol}{0}
\endgroup
\renewcommand{\cftlstlistingaftersnum}{\hfill--\hfill}
%
% Comandos para a recriação do comando \lstlistoflistings,
% ou seja, para criar a Lista de Códigos
\let\oldlstlistoflistings\lstlistoflistings
\renewcommand{\lstlistoflistings}{%
	\begingroup%
	\let\oldnumberline\numberline%
	\renewcommand{\numberline}{\lstlistingname\space\oldnumberline}%
	\oldlstlistoflistings%
	\endgroup}
% Cria um novo estilo de formatação de código
% para a Linguagem de programação Python
% a ser utilizada no ambiente "lstlisting".
\lstdefinestyle{Python}{
	language={Python},
	basicstyle=\ttfamily\small,
	identifierstyle=\color{black},
	keywordstyle=\color{blue},
	commentstyle=\color{green},
	stringstyle=\color{red},
	extendedchars=true,
	showspaces=false,
	showstringspaces=false,
	numbers=none,
	breaklines=true,
	backgroundcolor=\color{yellow!20},
	breakautoindent=true,
	captionpos=b,
	xleftmargin=0pt,
	frame=none
}
% Cria estilo de código em preto-e-branco
% usado apenas para impressão (mais barata)
%\lstdefinestyle{Python}{
%	language={Python},
%	basicstyle=\ttfamily\small,
%	identifierstyle=\color{black},
%	keywordstyle=\color{black},
%	commentstyle=\color{black},
%	stringstyle=\color{black},
%	extendedchars=true,
%	showspaces=false,
%	showstringspaces=false,
%	numbers=none,
%	breaklines=true,
%	backgroundcolor=\color{gray!10},
%	breakautoindent=true,
%	captionpos=b,
%	xleftmargin=0pt,
%	frame=none
%}

\usepackage{subcaption}

\makeatletter
\renewcommand{\ABNTEXcaptionfontedelim}{,}
\renewcommand{\fonte}[2][\fontename]{%
	\M@gettitle{#2}%
	\memlegendinfo{#2}%
	\par
	\begingroup
		\@parboxrestore
		\if@minipage
			\@setminipage
		\fi
		\small
     	\configureseparator
		\@makecaption{\small #1}{\ignorespaces\small #2}\par
	\endgroup
}
\makeatother

\newcommand{\codigofonte}{
	\vspace{-0.4cm}
	\fonte{Elaborado pelo autor, 2019.}
	\vspace{0.4cm}
}

\makeatletter
\newcommand{\noEquationSpacing}[1]{
	{
		\setlength{\belowdisplayskip}{0pt} \setlength{\belowdisplayshortskip}{0pt}
		\setlength{\abovedisplayskip}{0pt} \setlength{\abovedisplayshortskip}{0pt}
		#1
	}
}
\makeatother

% ---
% Pacotes de citações
% ---
\usepackage[brazilian,hyperpageref]{backref}	 % Paginas com as citações na bibl
% Pacote abntex2cite para citações no padrão ABNT
\usepackage[alf]{abntex2cite}
% --- 
% CONFIGURAÇÕES DE PACOTES
% --- 



% Backref para a escrita do trabalho
%\renewcommand{\backrefpagesname}{Citado na(s) página(s):~}
%\renewcommand{\backref}{}
%\renewcommand*{\backrefalt}[4]{
%	\ifcase #1 %
%		Nenhuma citação no texto.%
%	\or
%		Citado na página #2.%
%	\else
%		Citado #1 vezes nas páginas #2.%
%	\fi}%
% ---

% Backref para produção
\renewcommand{\backrefpagesname}{}
\renewcommand{\backref}{}
\renewcommand*{\backrefalt}[4]{}

% ---
% Informações de dados para CAPA e FOLHA DE ROSTO
% ---
\titulo{\textbf{Uma introdução ao cálculo variacional e ao método de Rayleigh-Ritz com aplicações em \textit{Python}.}}
\autor{EDUARDO JOSÉ DE OLIVEIRA}
\local{Anápolis}
\data{2019}
\orientador{Prof. Me. Tiago de Lima Bento Pereira}
%\coorientador{Titulação e Nome do coorientador}
\instituicao{%
Universidade Estadual de Goiás
  \par
Câmpus Anápolis de Ciências Exatas e Tecnológicas Henrique Santillo
  \par
Curso de Matemática}
\tipotrabalho{Trabalho de Curso (Graduação)}
% O preambulo deve conter o tipo do trabalho, o objetivo, 
% o nome da instituição e a área de concentração 
\preambulo{Trabalho de Curso (TC) apresentado a Coordenação Adjunta de TC, como parte dos requisitos para obtenção do título de Graduado no Curso de Matemática da Universidade Estadual de Goiás.} %sob a orientação do Professor(a) titulação e nome do professor(a).}
% ---


% ---
% Configurações de aparência do PDF final

% alterando o aspecto da cor azul
\definecolor{blue}{RGB}{41,5,195}

% informações do PDF
\makeatletter
\hypersetup{
     	%pagebackref=true,
		pdftitle={\@title}, 
		pdfauthor={\@author},
    	pdfsubject={\imprimirpreambulo},
	    pdfcreator={LaTeX with abnTeX2},
		pdfkeywords={abnt}{latex}{abntex}{abntex2}{trabalho acadêmico}, 
		colorlinks=false,       		% false: boxed links; true: colored links
    	linkcolor=blue,          	% color of internal links
    	citecolor=blue,        		% color of links to bibliography
    	filecolor=magenta,      		% color of file links
		urlcolor=blue,
		bookmarksdepth=4
}
\makeatother
% --- 

% Define o tamanho da indentação do paragrafo
\setlength{\parindent}{1.5cm}
% Define o espaçamento entre um parágrafo e outro
\setlength{\parskip}{0.2cm}

% Customizações para o Curso de Matemática do Campus CET
% da Universidade Estadual de Goiás.
\usepackage{abntex2matematicaCCET}

% Pacote genealogytree. Usado apenas para os símbolos de
% nascimento e morte, usados nessas datas no capítulo
% sobre história.
\usepackage{genealogytree}
% Cria um comando utilizado para inserir a data de nascimento
% e morte como nota de rodapé.
\newcommand{\bdDate}[2]{\footnote{\gtrsymBorn\text{ }#1 - \gtrsymDied\text{ }#2}}


\usepackage{mathptmx}
\renewcommand{\ABNTEXchapterfont}{\normalfont}

% 
\usepackage{pdfpages}

% pacotes utilizados para a configuração do índice remissivo
\usepackage{imakeidx}
\usepackage{hyperref}

% Altera as configurações do index (página de índice remissivo)
% alterando o estilo da página para o estilo 'abntchapfirst' do
% abntex, fazendo com que o número de página vá para o local
% correto.
\indexsetup{
  othercode={%
    \thispagestyle{abntchapfirst}
  }
}

% ---
% compila o indice
% ---
\makeindex
\makeindex[name=remissivo, title={Índice Remissivo}, options=-s indexstyle, columns=2]

\begin{document}
% Seleciona o idioma do documento (conforme pacotes do babel)
\selectlanguage{brazil}
% Retira espaço extra obsoleto entre as frases.
\frenchspacing


% ----------------------------------------------------------
% ELEMENTOS PRÉ-TEXTUAIS
% ----------------------------------------------------------
\pretextual
% ---
% Capa
% ---
\imprimircapa
% ---
% ---
% Folha de rosto
% (o * indica que haverá a ficha bibliográfica)
% ---
\imprimirfolhaderosto*
% ---

% ---
% Inserir a ficha bibliografica
% ---

% Isto é um exemplo de Ficha Catalográfica, ou ``Dados internacionais de
% catalogação-na-publicação''. Você pode utilizar este modelo como referência. 
% Porém, provavelmente a biblioteca da sua universidade lhe fornecerá um PDF
% com a ficha catalográfica definitiva após a defesa do trabalho. Quando estiver
% com o documento, salve-o como PDF no diretório do seu projeto e substitua todo
% o conteúdo de implementação deste arquivo pelo comando abaixo:
%
 \begin{fichacatalografica}
     \includepdf[pages=1]{arquivos/ficha_catalografica.pdf}
 \end{fichacatalografica}

%\begin{fichacatalografica}
%	\sffamily
%	\vspace*{\fill}					% Posição vertical
%	\begin{center}					% Minipage Centralizado
%	\fbox{\begin{minipage}[c][8cm]{13.5cm}		% Largura
%	\small
%	\imprimirautor
%	%Sobrenome, Nome do autor
%	
%	\hspace{0.5cm} \imprimirtitulo  / \imprimirautor. --
%	\imprimirlocal, \imprimirdata-
%	
%	\hspace{0.5cm} \pageref{LastPage} p. : il. (algumas color.) ; 30 cm.\\
%	
%	\hspace{0.5cm} \imprimirorientadorRotulo~\imprimirorientador\\
%	
%	\hspace{0.5cm}
%	\parbox[t]{\textwidth}{\imprimirtipotrabalho~--~\imprimirinstituicao,
%	\imprimirdata.}\\
%	
%	\hspace{0.5cm}
%		1. Cálculo Variacional. 
%		2. Equação de Euler-Lagrange. 
%		3. Método de Rayleigh-Ritz. 
%		4. Programação. 
%		5. Python. 
%		I. Orientador. 
%		II. Universidade xxx.
%		III. Faculdade de xxx.
%		IV. Título 			
%	\end{minipage}}
%	\end{center}
%\end{fichacatalografica}
% ---

% ---
% Inserir folha de aprovação
% ---

% Isto é um exemplo de Folha de aprovação, elemento obrigatório da NBR
% 14724/2011 (seção 4.2.1.3). Você pode utilizar este modelo até a aprovação
% do trabalho. Após isso, substitua todo o conteúdo deste arquivo por uma
% imagem da página assinada pela banca com o comando abaixo:
%
\includepdf{arquivos/folha_aprovacao.pdf}
\cleardoublepage
%
%\begin{folhadeaprovacao}
%
%  \begin{center}
%  {\ABNTEXchapterfont\bfseries\large\imprimirtitulo}
%%    {\ABNTEXchapterfont\large\imprimirautor}
%
%    \vspace*{\fill}\vspace*{\fill}
%    \begin{center}
%    {\ABNTEXchapterfont\large\imprimirautor}
%%      \ABNTEXchapterfont\bfseries\Large\imprimirtitulo
%    \end{center}
%    \vspace*{\fill}
%    
%%    \hspace{.45\textwidth}
%%    \begin{minipage}{.5\textwidth}
%%        \imprimirpreambulo
%%    \end{minipage}%
%%    \vspace*{\fill}
%\end{center}
%\vfill
%
%   Trabalho de Curso de Matemática apresentado à Banca Examinadora como parte dos requisitos para a obtenção do grau de graduado em Licenciatura em Matemática. 
%   
%   Banca Examinadora do Trabalho de Curso de Matemática do Câmpus Anápolis de Ciências Exatas e Tecnológicas Henrique Santillo da Universidade Estadual de Goiás, \imprimirlocal, 26 de novembro de 2019.
%
%\vfill
%
%   \assinatura{\textbf{\imprimirorientador} Presidente da Banca Examinadora \\ Orientador(a) } 
%   \vfill
%   \assinatura{\textbf{Dr. Fabiano Boaventura de Miranda} \\ 1º Membro da Banca Examinadora}
%   \vfill
%   \assinatura{\textbf{Me. Cleber Giugioli Carrasco} \\ 2º Membro da Banca Examinadora}
%\vfill
%  
%\end{folhadeaprovacao}
% ---

% ---
% Dedicatória
% ---
\begin{dedicatoria}
	\vspace*{\fill}
	\centering
	\noindent
	\textit{
		Este trabalho é dedicado à todos aqueles que,\\
		de alguma forma, mesmo sem consciência de tal feito,\\
		possibilitaram a minha caminhada até aqui.
	} \vspace*{\fill}
\end{dedicatoria}
% ---

% ---
% Agradecimentos
% ---
\begin{agradecimentos}[AGRADECIMENTOS]
Agradeço a minha mãe, Elza Oliveira, e meu irmão, Danilo Oliveira, por me acompanharem até aqui e possibilitarem que eu concluísse a graduação. Quero agradecer, de forma póstuma, meu pai, Lourenço Bernardes, por, mesmo em sua partida, promoveu, em mim, tamanho crescimento emocional e intelectual. Por último, gostaria de agradecer a toda a minha família.

Agradeço ao professor Tiago de Lima Bento Pereira por ter aceito me orientar nos estudos e na elaboração desse trabalho e por ter o feito com tamanha dedicação e empenho. 

Agradeço aos professores que se dispuseram a fazer parte da banca e a ler, avaliar e propor melhorias a esse trabalho. Agradeço, também, a todos os demais professores que tiveram um papel importante ao longo da minha formação.

Agradeço aos meus amigos e colegas que me apoiaram e estiveram ao meu lado, pessoalmente ou por meio dos incríveis mensageiros instantâneos, durante essa jornada. 

Agradeço, ainda, a todos aqueles que, mesmo desconhecidos, acalentaram meu coração, com pequenos gestos e sorrisos, ao longo dessa jornada.

Por último, gostaria de agradecer a todos os integrantes do Grupo Alegria, especialmente do Grupo Alegria Anápolis, por ensinarem que cada um de nós é capaz de realizar muito mais do que imagina, que o verdadeiro amor está nas pequenas coisas e, principalmente, que através do amor é possível mudar toda a história da humanidade.
\end{agradecimentos}
% ---

% ---
% Epígrafe
% ---
\begin{epigrafe}
    \vspace*{\fill}
	\begin{flushright}
		\textit{"Durante toda a sua vida, estudara o universo, \\
		mas desprezara sua mais clara mensagem:\\
		para criaturas pequenas como nós,\\
		a vastidão só é suportável através do amor." \\
		(Carl Sagan)}
	\end{flushright}
\end{epigrafe}
% ---

% ---
% RESUMOS
% ---

% resumo em português
\setlength{\absparsep}{18pt} % ajusta o espaçamento dos parágrafos do resumo
\begin{resumo}[RESUMO]
Apresenta-se neste trabalho uma introdução ao cálculo variacional e ao método de Rayleigh-Ritz. Um dos principais problemas pertinentes ao cálculo variacional é o de encontrar uma função exata que torna um determinado funcional estacionário. Mediante uma revisão bibliográfica buscou-se apresentar ferramentas para se encontrar a função exata que torna o funcional estacionário, dentre as quais, a primeira dessas ferramentas, apresentadas no trabalho, é a equação de Euler-Lagrange. Outra ferramenta apresentada é o método de Rayleigh-Ritz, que visa aproximar a função exata desejada. Complementando os estudos do método de Rayleigh-Ritz, são apresentadas, também, aplicações com a linguagem de programação \textit{Python}.

\textbf{Palavras-chave}: Métodos Variacionais. Equação de Euler-Lagrange. Método de Rayleigh-Ritz. Programação. \textit{Python}.
\end{resumo}

% ---
% inserir lista de ilustrações
% ---
\pdfbookmark[0]{\listfigurename}{lof}
\listoffigures*
\cleardoublepage
% ---

% Lista de códigos
\pdfbookmark[0]{\lstlistlistingname}{lol}
\begin{KeepFromToc}
\lstlistoflistings
\end{KeepFromToc}
\cleardoublepage

% ---
% inserir lista de tabelas
% ---
\pdfbookmark[0]{\listtablename}{lot}
\listoftables*
\cleardoublepage
% ---

% ---
% inserir lista de abreviaturas e siglas
% ---
%\begin{siglas}
%  \item[ABNT] Associação Brasileira de Normas Técnicas
%  \item[abnTeX] ABsurdas Normas para TeX
%\end{siglas}
% ---

% ---
% inserir lista de símbolos
% ---
%\begin{simbolos}
%  \item[$ \Gamma $] Letra grega Gama
%  \item[$ \Lambda $] Lambda
%  \item[$ \zeta $] Letra grega minúscula zeta
%  \item[$ \in $] Pertence
%\end{simbolos}
% ---


% ---
% inserir o sumario
% ---
\pdfbookmark[0]{\contentsname}{toc}
\tableofcontents*
\cleardoublepage
% ---

% ----------------------------------------------------------
% ELEMENTOS TEXTUAIS
% ----------------------------------------------------------
\textual

% ----------------------------------------------------------
% Introdução (exemplo de capítulo sem numeração, mas presente no Sumário)
% ----------------------------------------------------------
\chapter*[INTRODUÇÃO]{INTRODUÇÃO}
\addcontentsline{toc}{chapter}{INTRODUÇÃO}

%{\color{red}Escrever a introdução do trabalho.}

O cálculo variacional engloba diversos problemas, sendo um dos mais tratados, o de minimizar ou maximizar funcionais, que são, fundamentalmente, funções que dependem de outras funções \cite{mefassan}.

Desde o enuncidado do problema da braquistócrona, em 1696, que visa encontrar a curva em que uma partícula precisa descrever para sair de um ponto A e chegar a um ponto B, ambos os pontos em um plano vertical, no menor tempo possível estando sobre ação apenas da força gravitacional \cite{calcvar}, diversas técnicas surgiram de modo a descrever esse fenômeno.

Algumas das principais contribuições para a área do cálculo variacional se devem aos matemáticos Euler e Lagrange, criando generalizações para métodos específicos utilizados, até então, na resolução de cada problema proposto \cite{hist_courant}.

Além dos métodos que permitem a resolução analítica dos problemas, surgem métodos que fornecem resoluções aproximadas e que são utilizados, principalmente, em aplicações à engenharia. O método de Rayleigh-Ritz, por exemplo, prevê o uso de uma função aproximadora no lugar da função exata, permitindo, assim, resoluções aproximadas para o problema do funcional \cite{mefassan}.

A justificativa para o trabalho é a importância acadêmica dos temas, tendo em vista a grande gama de aplicações do cálculo variacional e do método de Rayleigh-Ritz, desde os problemas clássicos, como a braquistócrona, a problemas não convencionais, como, por exemplo, a solução de Schwarzschild para as Equações de Einstein, tratada por \citeonline{calcvar_campos}, e a determinação da forma que um cabo longo, inestensível, assume quando suspenso por suas extremidades, em alturas iguais, o chamado problema da catenária, mostrado por \citeonline{calcvar}. 

O método de Rayleigh-Ritz, por sua vez, tem diversas aplicações, principalmente na área das engenharias, por exemplo, na determinação das frequências naturais, como tratado por \citeonline{RRM_Applications}, e no estudo da deflexão de vigas, de acordo com \citeonline{MRR_Deflex}. O método tem sido aplicado, atualmente, junto a tecnologias como as técnicas de aprendizado de máquinas, conforme \citeonline{deep_ritz}, objetivando abordagens modernas da área de inteligência artificial para os problemas do cálculo variacional. 

O primeiro objetivo do trabalho é o de introduzir, de forma clara e concisa, o cálculo variacional por meio do estudo das Equações de Euler-Lagrange para funcionais que dependem de uma única variável, da função e das suas derivadas, até a ordem $n$ desejada. O segundo objetivo é explicar o método de Rayleigh-Ritz, de forma simples e introdutória, desenvolvendo exemplos básicos. O terceiro, e último, objetivo do trabalho consiste em apresentar formas de se utilizar a computação para os cálculos do método de Rayleigh-Ritz por meio da linguagem de programação \textit{Python}.

O trabalho foi realizado por meio de um levantamento bibliográfico em artigos, dissertações, livros, artigos e outros documentos acadêmicos.

A monografia foi dividida em quatro capítulos, tendo, ainda, três apêndices. O primeiro capítulo, entitulado de Contexto Histórico, apresenta, de forma breve e sucinta, a visão geral e o contexto histórico sobre os máximos e mínimos, o cálculo variacional, o método de Rayleigh-Ritz e a linguagem de programação \textit{Python}. 

O segundo capítulo, Cálculo Variacional, expõe um dos problemas clássicos do cálculo variacional e, partindo desse problema, são deduzidas as equações de Euler-Lagrange para funcionais que dependem de uma variável, da função e de derivadas da função até a ordem $n$, além de serem estudadas as Condições de Contorno Naturais e Essenciais. Além disso, são apresentados, no segundo capítulo, exemplos de uso da equação de Euler-Lagrange e das Condições de Contorno. 

O terceiro capítulo, Método de Rayleigh-Ritz, define o método de Rayleigh-Ritz e o trabalha de forma analítica, através de exemplo, além de iniciar o estudo das funções triangulares como funções de forma. 

O quarto capítulo, Utilizando o Método de Rayleigh-Ritz na Linguagem \textit{Python}, aborda o uso da linguagem de programação \textit{Python} para a resolução de problemas através do método de Rayleigh-Ritz, primeiramente de forma analítica e, logo em seguida, por meio das funções triangulares, cujo estudo foi iniciado no terceiro capítulo, que discretizam a curva exata.

No Apêndice A, Conceitos de Análise no $\mathbb{R}^n$, são apresentados alguns conceitos da área, tais como a definição de conjuntos compactos e a Regra de Leibniz para a derivação sob o sinal da integral, utilizados no decorrer do trabalho, por exemplo, ao deduzir a equação de Euler-Lagrange. No Apêndice B, Encontrando a Máxima Deflexão da Viga Estudada, é estudado a máxima deflexão por meio da solução analítica do primeiro exemplo estudado pelo método de Rayleigh-Ritz a fim de se ter comparações durante o estudo do método. Já o Apêndice C, entitulado Breve Introdução à Linguagem \textit{Python}, traz uma breve introdução sobre a linguagem, explicando como instalar a mesma, executar programas, as principais operações e, ainda, sobre como resolver sistemas lineares por meio dessa linguagem.

\chapter{CONTEXTO HISTÓRICO}
%\addcontentsline{toc}{chapter}{Contexto Histórico}

Para elucidar a história do cálculo variacional é importante mostrar um pouco da história dos máximos e mínimos de funções, problema pertinente ao cálculo diferencial, para, então, adentrar aos problemas de máximos e mínimos de funcionais, problema atribuído a área do cálculo variacional.

\section{Máximos e mínimos}

Os problemas de máximo e mínimo são corriqueiros na vida cotidiana, por exemplo, quando se quer encontrar o caminho com menor distância entre dois lugares para se caminhar uma menor distância, dentre vários outros problemas mais elaborados. Para esse exemplo específico não é necessário o uso de matemática avançada, porém, quanto mais complexidades são adicionadas aos problemas, mais ferramentas matemáticas são necessárias para a resolução, exata ou aproximada. Para simplificar estes processos, surgem os métodos para o cálculo de máximos e mínimos das funções.

Uma das primeiras formulações matemáticas próxima das atuais para os problemas de máximos e mínimos foi feita por Pierre de Fermat\bdDate{1601}{1665} em 1629 considerando curvas $y=f(x)$. Ele fez comparações de $f(x)$ e $f(x+E)$, onde $E$ é um número real positivo próximo de zero, ou seja, ele fez comparações do valor da função para pontos próximos. Esses valores geralmente são diferentes, porém, próximo de máximos ou mínimos a diferença se torna pequena. Deste modo, para achar os pontos de máximo ou mínimo, Fermat fazia
$$
	\frac{f(x+E)-f(x)}{E}
$$
e, após realizar a divisão, considerava $E=0$. Após considerar o valor de $E$ igual a $0$, Fermat igualava a expressão obtida a $0$, de onde conseguia extrair os valores das abscissas dos pontos de máximos e mínimos da função \cite{boyer}.

O que Fermat fez, de fato, foi igualar a primeira derivada de uma função a $0$. É importante ressaltar que esse método utilizado por Fermat veio antes mesmo da invenção do cálculo diferencial por Isaac Newton\bdDate{1642}{1727} em 1665-1666 e Gottfried Wilhelm Leibniz\bdDate{1646}{1716} em 1676, de forma independente \cite{boyer}.

%\textit{\color{red}Falar de modo geral que as maiores contribuições foram de Euler e Lagrange no cálculo variacional}

\section{O cálculo variacional}

%Johann Bernoulli, em 1969, deu ínicio ao estudo de uma classe de problemas cujo um dos mais antigos é o problema isoperimétrico. \cite{hist_courant}. O problema isoperimétrico consiste em "[d]ado um comprimento $L>0$, encontrar, dentre todas as curvas do plano de comprimento $L$, aquela que engloba a maior área" \cite[p. 1]{cbm_isoperimetrico}.

O ponto de partida do \index[remissivo]{Cálculo Variacional}cálculo variacional se deu com Johann Bernoulli\bdDate{1667}{1748}, em 1696, com a publicação do \index[remissivo]{Problema da braquistócrona}problema da braquistócrona no jornal científico \textit{Acta Eruditorium} \cite{hist_courant}.

O problema pode ser enunciado como:
\begin{citacao}
Sejam $A$ e $B$ dois pontos dados em um plano vertical. O problema da braquistócrona consiste em encontrar a curva que uma partícula M precisa descrever para sair de A e chegar em B no menor tempo possível, somente sob a ação da força da gravidade \cite[p. 3]{calcvar}.
\end{citacao}

O próprio Johann Bernoulli foi um dos matemáticos que solucionou o problema da braquistócrona. Ele retardou a publicação da sua solução para estimular os matemáticos do seu tempo a testarem suas habilidades nesse novo tipo de problema matemático \cite{hist_courant}. Além de Johann Bernoulli, soluções independentes foram encontradas por diversos matemáticos, como Jakob Bernoulli\bdDate{1654}{1705} (1697), L'Hospital\bdDate{1661}{1704} (1697), Leibniz (1697), e Newton (1697), \cite{hist_still}.

A solução de Jakob Bernoulli considerava o aspecto da curva variável, sendo considerado o primeiro grande passo para o desenvolvimento do cálculo variacional \cite{hist_still}. Nesse problema, a quantidade a ser minimizada depende de uma curva e não apenas de uma váriavel real \cite{hist_courant}, diferentemente dos problemas relacionados ao cálculo diferencial, o que torna necessária a construção de novas ferramentas matemáticas. 

Os métodos para a resolução de problemas deste tipo eram específicos com adaptações para cada caso, sendo que os métodos gerais para a resolução só foram desenvolvidos com o envolvimento dos matemáticos Euler e Lagrange nos estudos desses problemas \cite{hist_courant}.

\section{O método de Rayleigh-Ritz}

O processo de minimização de funcionais envolve diretamente a resolução de equações diferenciais que, na maioria das vezes, pode não ter solução analítica. Uma forma de se contornar esse problema é o uso de soluções aproximadas e, com esse intuito, surge o método de Rayleigh-Ritz, fazendo o uso de funções admissíveis.

O \index[remissivo]{Método de Rayleigh-Ritz}método de Rayleigh-Ritz carrega o nome de dois pesquisadores, Lord Rayleigh\bdDate{1842}{1919} e Walter Ritz\bdDate{1878}{1909}, porém seu desenvolvimento se deve, principalmente, a Walter Ritz, enquanto a solução apresentada por Lord Rayleigh é tratada como introdução, como será descrito abaixo.

Lord Rayleigh, em 1877, trabalhando com as energias potencial e cinética de sistemas, assumiu um padrão de vibração numa determinada frequência calculando a frequência de vibração livre por meio do equacionamento das energias potencial e cinética. Esse método ficou conhecido como \index[remissivo]{Método de Rayleigh}método de Rayleigh e a sua precisão depende de quão próximo o padrão de vibração escolhido está do correto \cite{LEISSA_2005}.

Em 1908 e 1909, Walter Ritz publicou dois artigos descrevendo procedimentos simples para a resolução de problemas de valor de contorno e de autovalores numericamente para qualquer nível de exatidão necessário usando funcionais \cite{LEISSA_2005}. Esse procedimento foi chamado de \index[remissivo]{Método de Ritz}método de Ritz.

Não se sabe exatamente quando o nome Rayleigh passou a ser agregado ao método de Ritz, transformando-se em "método de Rayleigh-Ritz". Uma das razões pelas quais isso ocorreu é o fato de que o método de Rayleigh pode ser considerado como um caso especial do método de Ritz quando uma única função admissível é utilizada para a aproximação \cite{LEISSA_2005}.

O método de Rayleigh foi utilizado frequentemente, porém, nas últimas décadas o método de Ritz ou, como é chamado hoje, de Rayleigh-Ritz se mostrou aplicável a uma gama enorme de problemas devido, principalmente, a revolução tecnológica promovida pelos computadores, a partir da invenção dos transistores e microprocessadores \cite{LEISSA_2005}.

\subsection{Aplicações do método de Rayleigh-Ritz}

O método de Rayleigh-Ritz possui aplicações nas mais diversas áreas sendo, porém, a análise estrutural uma das áreas em que o método é mais utilizado. Seu uso é empregado, principalmente, com o objetivo de encontrar as chamadas frequências naturais. As frequências naturais "indicam a taxa de oscilação livre da estrutura, depois de cessada [a] força que provocou o seu movimento. Em palavras similares, representa o quanto [a] estrutura vibra quando não há força aplicada sobre ela."\text{ }\cite[p. 1]{Vasquez2015}.

\citeonline{RRM_Applications} exemplificam essa aplicação ao procurar as frequências naturais em um tipo específico de viga, chamada de consola, que é uma viga apoiada apenas em uma de suas extremidades. A Figura \ref{fig:cantilever} mostra uma representação de uma viga desse tipo, onde a curva $w(x,t)$ representa o deslocamento dinâmico. Diversos outros trabalhos trazem essa mesma abordagem ao método, visando analisar frequências naturais de vibração, como, por exemplo, o trabalho de \citeonline{mrr_beams}, que estuda a frequência natural de vigas seguindo o modelo de Timoshenko e de Euler usando o método de Rayleigh-Ritz. \citeonline{GROSSI_2001} mostra a aplicação do método à problemas envolvendo placas, ao invés de vigas.

\begin{figure}[h]
	\caption{Modelo de uma viga consola vibrando.}
	\centering
	\begin{tikzpicture}
		\tkzInit[xmin=-0, xmax=6, ymin=-0.6, ymax=2]
		
		% wall
		\tkzDefPoints{
			0/0/V_1,
			0/2.2/V_2}
				
		% indicate end of cantilever
		\tkzDefPoints{
			6/1.4/E_1,
			6/0/E_2}
		
		% wall hatch
		\tkzDefPoints{
			0/0.8/WH_1,
			-0.4/0.4/WH_2,
			0/1.2/WH_3,
			-0.4/0.8/WH_4,
			0/1.6/WH_5,
			-0.4/1.2/WH_6,
			0/2/WH_7,
			-0.4/1.6/WH_8}
				
		% cantilever
		\tkzDefPoints {
			0/1.4/C_1,
			6/1.4/C_2}
				
		\tkzDrawSegment[color=black, line width=0.5mm](V_1, V_2)
			
		\tkzDrawSegment[color=black, line width=0.5mm](WH_1, WH_2)
		\tkzDrawSegment[color=black, line width=0.5mm](WH_3, WH_4)
		\tkzDrawSegment[color=black, line width=0.5mm](WH_5, WH_6)
		\tkzDrawSegment[color=black, line width=0.5mm](WH_7, WH_8)
			
		\tkzDrawSegment[color=black, line width=1.5mm](C_1, C_2)
		
		\tkzDrawSegment[color=black, line width=0.5mm, dashed](E_1, E_2)
			
		\tkzFct[domain=0:6,samples=1000, line width=0.5mm, dashed]{0.01*x*x + 1.45}
			
		\tkzDefPointByFct(6) \tkzGetPoint{A}
		\node (A) [above=1.4mm of A] {$w(x, t)$};
		\node at (0, -0.2) {$x=0$};
		\node at (6, -0.2) {$x=L$};
	\end{tikzpicture}
	\label{fig:cantilever}
	\legend{\ABNTEXfontereduzida Fonte: Adaptada de \citeonline[p. 23]{RRM_Applications}.}
\end{figure}

%\citeonline{ritz_image_proc} estuda o método de Rayleigh-Ritz para minimização da variação total usando \textit{splines} de duas variáveis, em triangulações e mostra aplicações desse estudo no processamento digital de imagens, mais especificamente ao problema de redução de ruídos.

%Um outro tipo de aplicação para o Método de Rayleigh-Ritz é o de encontrar as frequências naturais das chamadas consolas, vigas apoiadas apenas em uma das extremidades \cite{RRM_Applications}.

%{\color{red}Citar aplicações do Método de Rayleigh-Ritz.}

Além da abordagem convencional do método, existem trabalhos que visam aliar o método à técnicas de inteligência artificial, como o aprendizado de máquina. \citeonline{deep_ritz} afirmam que modelos baseados em redes neurais profundas podem ser utilizados em tarefas como a resolução de equações diferenciais parciais ou a modelagem molecular. Além disso, o trabalho propõe um método chamado de \textit{deep Ritz method} (método de Ritz profundo, em tradução literal) para a resolução de problemas variacionais. Esse método utiliza-se de representações de funções de redes neurais artificiais no contexto do método de Ritz \cite{deep_ritz}. 

Um dos exemplos mostrados por \citeonline{deep_ritz} para ilustrar a eficácia da abordagem é a solução para a equação de Poisson em duas dimensões. A Figura \ref{fig:deep_ritz_poisson} apresenta a solução utilizando dois métodos diferentes, sendo a Figura \ref{fig:deep_ritz_poisson_a} a solução pelo \textit{deep Ritz method} com 811 parâmetros e a Figura \ref{fig:deep_ritz_poisson_b} a solução pelo método das diferenças finitas com 1681 parâmetros.

\begin{figure}[h]
	\caption{Solução da equação de Poisson utilizando o \textit{deep Ritz method} e o método das diferenças finitas}
	\centering
	\begin{subfigure}{.49\textwidth}
		\centering
		\includegraphics[width=\linewidth]{../figuras/cite/deep_ritz_a.png}
		\caption{Solução pelo \textit{Deep Ritz Method}.}
		\label{fig:deep_ritz_poisson_a}
	\end{subfigure}
	\begin{subfigure}{.49\textwidth}
		\centering
		\includegraphics[width=\linewidth]{../figuras/cite/deep_ritz_b.png}
		\caption{Solução pelo método das diferenças finitas.}
		\label{fig:deep_ritz_poisson_b}
	\end{subfigure}
	\label{fig:deep_ritz_poisson}
	\legend{\ABNTEXfontereduzida Fonte: \citeonline[p. 5]{deep_ritz}.}
\end{figure}

Os exemplos acima citados mostram tanto aplicações clássicas quanto uma aplicação moderna do método de Rayleigh-Ritz e serve, inclusive, como motivação ao estudo do tema.

\section{A linguagem \textit{Python}}

A linguagem de programação \index[remissivo]{Python}\textit{Python} foi criada por volta de 1990 por Guido van Rossum no \textit{Stichting Mathematisch Centrum} nos Países Baixos \cite{Python_history}. Guido é o seu principal criador, porém, com o desenvolvimento \textit{open source}, a mesma apresenta colaborações de diversas pessoas \textemdash\text{ }atualmente, há cerca de mil colaboradores no repositório da linguagem no GitHub\footnote{\url{https://github.com/python/cpython/}.}. Em 2001, foi criada a \textit{Python Software Foundation}, organização sem fins lucrativos, responsável por possuir a propriedade intelectual relacionada a Linguagem \textit{Python} \cite{Python_history}.

As principais motivações para o uso da linguagem \textit{Python} neste trabalho é o seu funcionamento simples, a facilidade de uso, grande comunidade de usuários, além do fato de ser uma linguagem de programação gratuita e de código aberto tornando-a, deste modo, acessível.

Além dos diversos colaboradores diretos no desenvolvimento da linguagem, existem os colaboradores indiretos que criam, por exemplo, os pacotes com funções prontas para o uso. Dentre os pacotes científicos mais conhecidos estão alguns do ecossistema \textit{SciPy}:

\begin{itemize}
	\item \index[remissivo]{NumPy}\textit{NumPy} é um pacote utilizado para computação científica contendo objetos para trabalhar com \textit{arrays} (arranjos em português) multidimensionais, rotinas de operações em \textit{arrays}, transformadas de Fourier, álgebra linear, estatística, dentre outras funcionalidades \cite{NumPy}.
	
	\item \index[remissivo]{SciPy}\textit{SciPy} contém módulos para matemática, ciências e engenharia. As funções trazidas pela \textit{SciPy} permitem o trabalho com álgebra linear, cálculo, interpolação, manipulação de arquivos, otimização, processamento de sinais, entre outros \cite{SciPy}.
	
	\item \index[remissivo]{Matplotlib}\textit{Matplotlib} é uma biblioteca que permite plotar dados, tornando a visualização dos mesmos tão simples quanto possível \cite{Matplotlib}. Segundo \citeonline{Matplotlib}, a biblioteca possui um ambiente de estados de máquina similar ao utilizado no \textit{software} comercial MATLAB\footnote{O MATLAB, comercializado pela \textit{MathWorks}, é uma ferramenta matemática e um ambiente de desenvolvimento integrado voltado para o desenvolvimento de programas de natureza técnica, como, por exemplo, programas de cálculo numérico.}, trazendo uma experiência similar para usuários familiarizados com o MATLAB.
	
	\item \index[remissivo]{SymPy}\textit{SymPy} é uma biblioteca que contém classes e funções que permitem a manipulação simbólica de elementos matemáticos, isto é, os elementos matemáticos são representados de forma exata e não aproximados \cite{SymPy}. Por exemplo, ao se utilizar uma calculadora científica para realizar algum cálculo com o número $\pi$, será apresentado no visor o cálculo utilizando uma aproximação para $\pi$. Já na matemática simbólica, $\pi$ não seria aproximado e, portanto, o número continuaria sendo representado pela letra grega. É importante perceber que, em determinados casos, a abordagem aproximada é mais eficiente e, em outros, a abordagem simbólica.
\end{itemize}

Existem outros pacotes científicos no ecossistema do \textit{SciPy} e, também, fora do ecossistema, porém, serão citados, aqui, apenas esses devido ao fato de que os seus usos são voltados para a matemática e aplicações.

A linguagem e ambos os componentes citados são desenvolvidos em código aberto de forma colaborativa. Uma das vantagens dessa forma de desenvolvimento é o rápido aperfeiçoamento de suas funcionalidades, documentação e, também, a rápida correção de erros.

\chapter{CÁLCULO VARIACIONAL}
\label{cap:calc_var}

Um dos problemas pertinentes ao \index[remissivo]{Cálculo Variacional}cálculo variacional é o de encontrar uma função $y=y(x)$, satisfazendo as condições de contorno $y(x_1)=y_1$ e $y(x_2)=y_2$, que faça com que o funcional
\begin{equation}
	\label{eqn:cap_calc_var:int_funcional}
	I = \int_{x_1}^{x_2} f(x,y,y')dx\text{,}
\end{equation}
onde $f(x, y, y')$ é uma função de classe $C^1$ (Ver Definição \ref{def:cap_conceitos_analise:classe_ck} no Apêndice \ref{apend:regra_de_leibniz}), tenha valor mínimo ou máximo. Esse processo é chamado de minimizar ou maximizar o funcional. Minimizar ou maximizar um funcional é o mesmo que torná-lo estacionário. Assim, dizer que o funcional é estacionário é o mesmo que dizer que ele é mínimo ou máximo. Os valores $x_1$, $x_2$, $y_1$ e $y_2$ são números dados.

%Um dos problemas pertinentes ao \index[remissivo]{Cálculo Variacional}cálculo variacional é o de minimizar ou maximizar o funcional
%\begin{equation}
%	\label{eqn:cap_calc_var:int_funcional}
%	I = \int_{x_1}^{x_2} f(x,y,y')dx\text{.}
%\end{equation}

%Minimizar o funcional \eqref{eqn:cap_calc_var:int_funcional} é o processo de encontrar uma função $y=y(x)$, satisfazendo as condições de contorno $y(x_1)=y_1$ e $y(x_2)=y_2$,  que faça com que o mesmo tenha valor mínimo. De modo análogo, maximizar o funcional é encontrar uma função $y=y(x)$, com $y(x_1)=y_1$ e $y(x_2)=y_2$, que faz a integral \eqref{eqn:cap_calc_var:int_funcional} ser um valor máximo. Minimizar ou maximizar um funcional é o mesmo que torná-lo estacionário. Assim, dizer que o funcional é estacionário é o mesmo que dizer que ele é mínimo ou máximo. Os valores $x_1$, $x_2$, $y_1$ e $y_2$ são números dados.

%{\color{red}O que é minimizar, maximizar, extremos?}

Para para encontrar a função $y=y(x)$ procurada, são necessárias algumas ferramentas, dentre as quais a abordada neste estudo é a equação de Euler-Lagrange. Os conceitos, definições e resultados apresentados neste capítulo foram elaboradas segundo \citeonline{mefassan}, \citeonline{calcvar} e \citeonline{calcvar_campos}.

\section{Equação de Euler-Lagrange}
\label{sec:eq_euler_lagrange}

De início, é preciso demonstrar um Lema, conhecido como \index[remissivo]{Lema de Lagrange}Lema de Lagrange, que servirá como base para a dedução da equação de Euler-Lagrange.

\begin{lema}
\label{lema:cap_calcvar_lema_1}
Sejam $x_1 < x_2$ fixos e $G(x)$ uma função contínua particular para $x_1 \leqslant x \leqslant x_2$. Se $$\int_{x_1}^{x_2} \eta (x) G(x) dx = 0$$
para cada função diferenciável $\eta (x)$ tal que $\eta (x_1)=\eta (x_2)=0$, concluímos que $G(x)=0$, para todo $x$ de modo que $x_1 \leqslant x \leqslant x_2$.

\begin{proof}
Suponha que existe $\overline{x}$ tal que $x_1<\overline{x}<x_2$ e $G(\overline{x})\neq 0$. Podemos supor, sem perda de generalidade, que $G(\overline{x})>0$. Como $G$ é contínua, existe uma vizinhança $\overline{x_1} \leqslant \overline{x} \leqslant \overline{x_2}$ onde $G(x)>0$ em toda a vizinhança.

É possível construir a seguinte função $\eta (x)$:
$$
\eta (x) = 
	\begin{cases}
		0 											& \mbox{para } x_1 \leqslant x < \overline{x_1}\\
		(x-\overline{x_1})^2(x-\overline{x_2})^2	& \mbox{para } \overline{x_1} \leqslant x \leqslant \overline{x_2}\\
		0											& \mbox{para } \overline{x_2} < x \leqslant x_2
	\end{cases}
$$
e então reescrever a integral do seguinte modo:
$$\int_{x_1}^{x_2}\eta (x) G(x)dx =\int_{\overline{x_1}}^{\overline{x_2}}(x-\overline{x_1})^2(x-\overline{x_2})^2G(x)dx\text{.}$$

Como $G(x) > 0$ em $\overline{x_1} \leqslant x \leqslant \overline{x_2}$, a integral do lado direito é estritamente positiva, contradizendo a hipótese. Portanto, $G(\overline{x})=0$. A demonstração considerando $G(\overline{x})<0$ é análoga.
\end{proof}
\end{lema}

Suponha $x_1$, $x_2$, $y_1$, $y_2$ dados, $f$ uma função de $x$, $y$ e $y'$ duas vezes diferenciável. É preciso construir uma família de \index[remissivo]{Função Admissível}funções admissíveis\footnote{Em outras literaturas, essas funções admissíveis podem ser chamadas, também, de funções aproximadoras, porém, devido ao uso de nomes parecidos em outros capítulos deste trabalho, foi preferível o emprego do nome funções admissíveis.}, $Y_{\varepsilon}(x)$, definida por:
\begin{equation}\label{eqn:cap_calc_var:func_admissible}
	Y_{\varepsilon}(x)=y(x)+\varepsilon \eta (x)\text{,}
\end{equation}
onde $\eta (x)$ é uma função diferenciável arbitrária para a qual $\eta (x_1)=\eta (x_2) = 0$. O número $\varepsilon$ é o parâmetro da família. A representação gráfica das funções admissíveis pode ser vista na Figura \ref{fig:funcoes_admissiveis}. Assim, a derivada de $Y$ em relação a $x$, $Y'(x)$, é
\begin{equation}\label{eqn:cap_calc_var:func_admissible_diff}
	Y'(x)=y'(x)+\varepsilon \eta '(x)\text{.}
\end{equation}

\begin{figure}[!h]
	\caption{Representação gráfica das funções admissíveis.}
	\centering
	
	\resizebox{0.75\textwidth}{!}
	{
		\input{../figuras/cap_calcvar/funcoes_aproximadoras.tex}
	}
	
	\label{fig:funcoes_admissiveis}
	\legend{\ABNTEXfontereduzida Fonte: Elaborada pelo autor, 2019.}
\end{figure}

Reescrevendo a integral (\ref{eqn:cap_calc_var:int_funcional}) utilizando as funções admissíveis definidas, tem-se
\begin{equation}\label{eqn:cap_calc_var:int_funcional_approx}
I(\varepsilon)=\int_{x_1}^{x_2}f(x, Y_{\varepsilon}, Y')dx\text{.}
\end{equation}

Note que a função procurada $y(x)$ é o membro da família $Y_{\varepsilon}(x)$ quando $\varepsilon = 0$. Ou seja, se $\varepsilon = 0$ pode-se substituir $Y_{\varepsilon}$ e $Y'$ por $y$ e $y'$, respectivamente. Deste modo, a função que determina os extremos do funcional em \eqref{eqn:cap_calc_var:int_funcional_approx} é a mesma que determina os extremos em \eqref{eqn:cap_calc_var:int_funcional} tomando $\varepsilon=0$.

A condição necessária para que uma função de uma variável real tenha um extremo em algum ponto é que sua primeira derivada se anule nesse ponto. Então, é necessário que
\begin{equation}\label{eqn:cap_calc_var:extrem_condition}
	I'(0)=0\text{.}
\end{equation}

Com o intuito de que não haja confusão com as notações, é necessário deixar claro que $I'(\varepsilon)$ é a derivada de $I$ em relação a $\varepsilon$, enquanto que $y'$, $Y'$, $\eta'$ são derivadas em relação a $x$.

%{\color{red}Deixar explicito que $I'(\varepsilon)$ é a derivada de $I$ em relação a $\varepsilon$ enquanto que $Y'$ ou $y'$ é a derivada de $Y$ ou $y$ em relação a $x$.}

Utilizando a Regra de Leibniz (Teorema \ref{teorema:regra_de_leibniz} do Apêndice \ref{apend:regra_de_leibniz}), a derivada de (\ref{eqn:cap_calc_var:int_funcional_approx}) pode ser escrita como
$$I'(\varepsilon)=\int_{x_1}^{x_2} \frac{\partial f}{\partial \varepsilon} (x, Y_{\varepsilon}, Y') dx \text{,}$$
e, aplicando regra da cadeia, obtêm-se
$$I'(\varepsilon)=\int_{x_1}^{x_2}\left ( \frac{\partial f}{\partial x}\frac{\partial x}{\partial \varepsilon} + \frac{\partial f}{\partial Y} \frac{\partial Y}{\partial \varepsilon} + \frac{\partial f}{\partial Y'} \frac{\partial Y'}{\partial \varepsilon} \right )dx\text{,}$$
onde a primeira parcela do integrando é nulo, dado ao fato de que $x$ independe de $\varepsilon$, portanto $\dfrac{\partial x}{\partial \varepsilon}=0$, ou seja,
\begin{equation}\label{eqn:cap_calc_var:chain_rule}
I'(\varepsilon)=\int_{x_1}^{x_2}\left ( \frac{\partial f}{\partial Y}\frac{\partial Y}{\partial \varepsilon} + \frac{\partial f}{\partial Y'}\frac{\partial Y'}{\partial \varepsilon} \right ) dx \text{.}
\end{equation}

Derivando \eqref{eqn:cap_calc_var:func_admissible} em função de $\varepsilon$, tem-se $\dfrac{\partial Y}{\partial \varepsilon}=\dfrac{\partial y}{\partial \varepsilon}+\dfrac{\partial}{\partial \varepsilon}(\varepsilon \eta)$, de onde conclui-se que $\dfrac{\partial Y}{\partial \varepsilon}=\eta$, pois $y$ e $\eta$ independem de $\varepsilon$. O mesmo acontece com \eqref{eqn:cap_calc_var:func_admissible_diff}, donde verifica-se que $\dfrac{\partial Y'}{\partial \varepsilon}=\eta'$. Deste modo, de \eqref{eqn:cap_calc_var:chain_rule}, obtêm-se a integral
$$I'(\varepsilon)=\int_{x_1}^{x_2}\left ( 
	\frac{\partial f}{\partial Y} \eta +
	\frac{\partial f}{\partial Y'} \eta '
\right )dx \text{.}
$$

Para calcular $I'(0)$, tem-se que $\varepsilon=0$ e, então, podemos trocar $Y$ e $Y'$ por $y$ e $y'$, respectivamente, obtendo
$$
I'(0)=\int_{x_1}^{x_2}\left (
	\frac{\partial f}{\partial y} \eta +
	\frac{\partial f}{\partial y'} \eta '
\right )dx
$$
$$
I'(0)=
	\int_{x_1}^{x_2} \frac{\partial f}{\partial y}\eta dx
	+
	\int_{x_1}^{x_2} \frac{\partial f}{\partial y'}\eta' dx \text{.}
$$

Integrando a segunda parcela, por partes, tomando $u=\dfrac{\partial f}{\partial y'}$ e $dv=\eta'dx$ de onde obtêm-se $du=\dfrac{d}{dx}\left ( \dfrac{\partial f}{\partial y'} \right )dx$ e $v=\eta$, segue que,
$$
I'(0)=
	\int_{x_1}^{x_2} \frac{\partial f}{\partial y}\eta dx
	+
	\left (
	uv \Big|_{x_1}^{x_2} - \int_{x_1}^{x_2}vdu
	\right )
$$
\begin{equation}\label{eqn:cap_calc_var:integration_parts}
I'(0)=
	\int_{x_1}^{x_2} \frac{\partial f}{\partial y}\eta dx
	+
	\left (
		\frac{\partial f}{\partial y'}\eta \Biggr|_{x_1}^{x_2} - \int_{x_1}^{x_2} \frac{d}{dx}\left ( \frac{\partial f}{\partial y'} \right ) \eta dx
	\right )
\end{equation}

Sabe-se que $\dfrac{\partial f}{\partial y'}\eta \Big |_{x_1}^{x_2}=0$, devido ao fato de que $\eta(x_1)=\eta(x_2)=0$, portanto, \eqref{eqn:cap_calc_var:integration_parts} pode ser reescrita como
\begin{equation}
	\label{eqn:cap_calc_var:func_admitindo_eta_0}
	I'(0)=
		\int_{x_1}^{x_2} \frac{\partial f}{\partial y}\eta dx
		-
		\int_{x_1}^{x_2} \frac{d}{dx} \left ( \frac{\partial f}{\partial y'} \right ) \eta dx
\end{equation}
$$
I'(0)=\int_{x_1}^{x_2}\left (
	\frac{\partial f}{\partial y} -
	\frac{d}{dx}
	\left (
		\frac{\partial f}{\partial y'}
	\right )
\right )\eta dx
$$
que, a partir da condição necessária (\ref{eqn:cap_calc_var:extrem_condition}), deve ser igualada a $0$:
$$
I'(0)=\int_{x_1}^{x_2}\left (
	\frac{\partial f}{\partial y} -
	\frac{d}{dx}
	\left (
		\frac{\partial f}{\partial y'}
	\right )
\right )\eta dx = 0	\text{.}
$$
permitindo, pelo Lema \ref{lema:cap_calcvar_lema_1}, obter a seguinte equação:
\begin{equation}\label{eqn:cap_calc_var:euler_lagrange}
\frac{\partial f}{\partial y} - \frac{d}{dx} \left ( \frac{\partial f}{\partial y'} \right )=0 \text{.}
\end{equation}

A equação diferencial \eqref{eqn:cap_calc_var:euler_lagrange} é chamada de \index[remissivo]{Equação de Euler-Lagrange}equação de Euler-Lagrange e permite encontrar uma função $f$ que maximiza ou minimiza a integral (\ref{eqn:cap_calc_var:int_funcional}).

\section{Condições de contorno naturais e essenciais}
\label{sec:cond_contorno}

Durante o processo para a obtenção da função $y(x)$ que torna o funcional estacionário aparecem algumas condições de contorno que devem ser tratadas cuidadosamente. Por exemplo, tomando o funcional
$$
	I=\int_{x_1}^{x_2} f(x, y, y')dx
	\text{,}
$$
tem-se, da Seção \ref{sec:eq_euler_lagrange}, que sua condição de estacionariedade é dada por
\begin{equation}
	\label{eqn:cap_calc_var:cond_boundary}
	\int_{x_1}^{x_2} \left (
		\frac{\partial f}{\partial y}
		-
		\frac{d}{dx} \left (
			\frac{\partial f}{\partial y'}
		\right )
	\right ) \eta dx
	+
	\frac{\partial f}{\partial y'}\eta \Big |_{x_1}^{x_2} = 0
	\text{,}
\end{equation}
onde, como já tratado, $\eta$ representa uma variação da função exata conhecida.

Admitiu-se, em \eqref{eqn:cap_calc_var:func_admitindo_eta_0}, que $\eta(x_1)=\eta(x_2)=0$, porém isso nem sempre acontece. Existem casos em que, para que a condição de estacionariedade \eqref{eqn:cap_calc_var:cond_boundary} seja válida é preciso, primeiro, que a primeira parcela de \eqref{eqn:cap_calc_var:cond_boundary} seja nula, donde se resulta a equação de Euler-Lagrange
$$
	\frac{\partial f}{\partial y}
	-
	\frac{d}{dx}\left (
		\frac{\partial f}{\partial y'}
	\right )
	= 0
	\text{,}
$$
e, ainda, que
$$
	\frac{\partial f}{\partial y'}\eta \Big |_{x_1}^{x_2} = 0
	\text{,}
$$
de onde, geralmente, surgem as duas igualdades
\begin{equation}
	\label{eqn:cap_calc_var:condicao_natural_d1}
	\frac{\partial f}{\partial y'} \Big |_{x=x_1} = 0
	\text{,}
\end{equation}
\begin{equation}
	\label{eqn:cap_calc_var:condicao_natural_d2}
	\frac{\partial f}{\partial y'} \Big |_{x=x_2} = 0
	\text{.}
\end{equation}

É importante deixar claro que pode acontecer, por exemplo, de $\eta(x_1)=0$ e $\eta(x_2)\neq 0$, ou vice-versa, e, consequentemente, reduz-se uma dessas condições de contorno.

Essas condições de contorno são denominadas condições de \index[remissivo]{Condições de Contorno Naturais}contorno naturais do problema ou, ainda, \index[remissivo]{Condições de Contorno de Neumann}problema de valor de contorno de Neumann. Elas tendem a aparecer normalmente durante o processo de encontrar $y(x)$, tornando o funcional estacionário.

Para o caso de funcionais que dependem de derivadas de ordem superior, da forma
$$
	I=\int_{x_1}^{x_2} f(x, y, y', \dots, y^{(n)}) dx
	\text{,}
$$
aparecem diversas condições de contorno parecidas com \eqref{eqn:cap_calc_var:condicao_natural_d1} e \eqref{eqn:cap_calc_var:condicao_natural_d2}. Um destes exemplos aparece em \eqref{eqn:cap_calc_var:cond_with_naturalbound}.

Outro tipo de condições de contorno que aparecem com problemas do cálculo variacional são condições de contorno geométricas. As condições de contorno geométricas precisam, necessariamente serem satisfeitas e são denominadas de condições de \index[remissivo]{Condições de Contorno Essenciais}\index[remissivo]{Condições de Contorno de Dirichlet}contorno essenciais ou, ainda, problemas de valor de contorno de Dirichlet.

A equação de Euler-Lagrange é uma equação diferencial e, quando resolvida, fornece uma solução geral, em função de suas constantes. Para determinar essas constantes e, deste modo, a solução particular para a equação de Euler-Lagrange trabalhada é necessário o uso tanto das condições de contorno naturais quanto das condições de contorno essenciais, como poderá ser visto no Exemplo \ref{ex:cond_contorno} da Seção \ref{sec:calcvar_exemplos}.

\section{Equação de Euler-Lagrange para funcionais que dependem das derivadas de ordem superior}
\label{sec:eq_euler_lagrange_superior}

Existem também, funcionais que dependem de mais funções, funções de mais de uma variável ou, ainda, que dependem de derivadas de ordem superior. O último caso será mostrado aqui, tendo em vista seu uso nos próximos capítulos. Considere o funcional
\begin{equation}
	\label{eqn:cap_calc_var:funcional_n_derivadas}
	I=\int_{x_1}^{x_2} f(x, y, y', y'', \dots, y^{(n)})dx
	\text{,}
\end{equation}
onde $y^{(n)}$ representa a $n$-ésima derivada de $y$. Pode-se aproximar $y(x)$ através de \index[remissivo]{Função Admissível}funções admissíveis $Y_{\varepsilon}(x)=y(x)+\varepsilon \eta (x)$, onde $\eta(x_1)=\eta(x_2)=0$ e $\eta(x)$ deve ser uma função de classe $C^n$ (Ver Definição \ref{def:cap_conceitos_analise:classe_ck} no Apêndice \ref{apend:regra_de_leibniz}). Desse modo,
$$
	Y'(x)=y'(x)+\varepsilon \eta ' (x)
	\text{,}
$$
$$
	Y''(x)=y''(x)+\varepsilon \eta '' (x)
	\text{,}
$$
$$
	\vdots
$$
$$
	Y^{(n)} (x)= y^{(n)}(x)+\varepsilon \eta^{(n)} (x)
	\text{.}
$$

Substituindo $y$, $y'$, $y''$, $\dots$, $y^{(n)}$ por suas funções admissíveis $Y$, $Y'$, $Y''$, $\dots$, $Y^{(n)}$ em \eqref{eqn:cap_calc_var:funcional_n_derivadas}, o funcional pode ser escrito como
$$
	I(\varepsilon) = \int_{x_1}^{x_2}
		f(x, Y_{\varepsilon}, Y', Y'', \dots, Y^{(n)})
		dx
	\text{,}
$$
donde, derivando em função de $\varepsilon$, por meio da Regra de Leibniz (Teorema \ref{teorema:regra_de_leibniz} do Apêndice \ref{apend:regra_de_leibniz}), tem-se
\begin{equation}
	\label{eqn:cap_calc_var:diff_func_n_derivadas_leibniz}
	I'(\varepsilon) = 
	\int_{x_1}^{x_2}
		\frac{\partial f}{\partial \varepsilon}
		(x, Y_{\varepsilon}, Y', Y'', \dots, Y^{(n)})
		dx
	\text{.}
\end{equation}

Aplicando a Regra da Cadeia em \eqref{eqn:cap_calc_var:diff_func_n_derivadas_leibniz}, $I'(\varepsilon)$ pode ser escrita como
$$
	I'(\varepsilon)=\int_{x_1}^{x_2}
	\left (
		\frac{\partial f}{\partial x}
		\frac{\partial x}{\partial \varepsilon}
		+
		\frac{\partial f}{\partial Y}
		\frac{\partial Y}{\partial \varepsilon}
		+
		\frac{\partial f}{\partial Y'}
		\frac{\partial Y'}{\partial \varepsilon}
		+
		\frac{\partial f}{\partial Y''}
		\frac{\partial Y''}{\partial \varepsilon}
		+
		\cdots
		+
		\frac{\partial f}{\partial Y^{(n)}}
		\frac{\partial Y^{(n)}}{\partial \varepsilon}
	\right ) dx
	\text{,}
$$
onde $\dfrac{\partial x}{\partial \varepsilon} = 0$, pois $x$ não depende de $\varepsilon$, assim,
\begin{equation}
	\label{eqn:cap_calc_var:func_n_derivadas_pos_regra_cadeia}
	I'(\varepsilon)=\int_{x_1}^{x_2}
	\left (
		\frac{\partial f}{\partial Y}
		\frac{\partial Y}{\partial \varepsilon}
		+
		\frac{\partial f}{\partial Y'}
		\frac{\partial Y'}{\partial \varepsilon}
		+
		\frac{\partial f}{\partial Y''}
		\frac{\partial Y''}{\partial \varepsilon}
		+
		\cdots
		+
		\frac{\partial f}{\partial Y^{(n)}}
		\frac{\partial Y^{(n)}}{\partial \varepsilon}
	\right ) dx
	\text{.}
\end{equation}

Derivando as funções admissíveis $Y$, $Y'$, $Y''$, $\dots$, $Y^{(n)}$ em relação a $\varepsilon$, como já feito anteriormente, é possível substituir em \eqref{eqn:cap_calc_var:func_n_derivadas_pos_regra_cadeia}, os valores de $\dfrac{\partial Y}{\partial \varepsilon}$ por $\eta(x)$ e $\dfrac{\partial Y^{(i)}}{\partial \varepsilon}$ por $\eta^{(i)}(x)$ onde $i=1, 2, \dots, n$. Assim, \eqref{eqn:cap_calc_var:func_n_derivadas_pos_regra_cadeia} pode ser reescrito como
\begin{equation}
	\label{eqn:cap_calc_var:func_n_derivadas_replace_0}
	I'(\varepsilon)=
	\int_{x_1}^{x_2} \left (
		\frac{\partial f}{\partial Y} \eta
		+
		\frac{\partial f}{\partial Y'} \eta'
		+
		\frac{\partial f}{\partial Y''} \eta''
		+
		\cdots
		+
		\frac{\partial f}{\partial Y^{(n)}} \eta^{(n)}
	\right ) dx
	\text{.}
\end{equation}

Fazendo $\varepsilon=0$, pode-se substituir $Y$, $Y'$, $Y''$, $\dots$, $Y^{(n)}$ por $y$, $y'$, $y''$, $\dots$, $y^{(n)}$, respectivamente, então
$$
	I'(0)= \int_{x_1}^{x_2} \left (
		\frac{\partial f}{\partial y} \eta
		+
		\frac{\partial f}{\partial y'} \eta'
		+
		\frac{\partial f}{\partial y''} \eta''
		+
		\cdots
		+
		\frac{\partial f}{\partial y^{(n)}} \eta^{(n)}
	\right )dx
$$
\begin{equation}
	\label{eqn:cap_calc_var:func_n_derivadas_pos_separar}
	I'(0)= 
	\int_{x_1}^{x_2}
		\frac{\partial f}{\partial y} \eta
	dx
	+		
	\int_{x_1}^{x_2}
		\frac{\partial f}{\partial y'} \eta'
	dx
	+
	\int_{x_1}^{x_2}
		\frac{\partial f}{\partial y''} \eta''
	dx
	+
	\cdots
	+
	\int_{x_1}^{x_2}
		\frac{\partial f}{\partial y^{(n)}} \eta^{(n)}
	dx
	\text{.}
\end{equation}

As integrações para o caso geral serão omitidas aqui. Nas duas subseções proximas, será mostrado o processo para o caso em que $n=2$ e a equação geral para derivadas até a ordem $n$.

\subsection{Processo para funcionais que dependem de derivadas de segunda ordem}

Fazendo uso de \eqref{eqn:cap_calc_var:funcional_n_derivadas} e \eqref{eqn:cap_calc_var:func_n_derivadas_pos_separar} pode-se considerar o caso em que $n=2$, onde o funcional é dado por
$$
	I=\int_{x_1}^{x_2} f(x, y, y', y'')dx
	\text{,}
$$
e $I'(0)$ é dado por
\begin{equation}
	\label{eqn:cap_calc_var:func_2_derivada_integracao}
	I'(0)=
	\int_{x_1}^{x_2}
		\frac{\partial f}{\partial y}
		\eta
	dx
	+
	\int_{x_1}^{x_2}
		\frac{\partial f}{\partial y'}
		\eta'
	dx
	+
	\int_{x_1}^{x_2}
		\frac{\partial f}{\partial y''}
		\eta''
	dx
	\text{.}
\end{equation}

A segunda parcela pode ser integrada, por partes, com $u=\dfrac{\partial f}{\partial y'}$ e $dv=\eta'dx$, donde 
$du=\dfrac{d}{dx} \left (
	\dfrac{\partial f}{\partial y'}
\right ) dx$ e $v=\eta$, logo
$$
	\int_{x_1}^{x_2} \frac{\partial f}{\partial y'}\eta ' dx
	=
	\frac{\partial f}{\partial y'}\eta \Big |_{x_1}^{x_2}
	-
	\int_{x_1}^{x_2}
		\frac{d}{dx} \left (
			\frac{\partial f}{\partial y'}
		\right ) \eta dx
	\text{,}
$$
mas $\eta(x_1)=\eta(x_2)=0$, ou seja, a integral pode ser reescrita como
\begin{equation}
	\label{eqn:cap_calc_var:func_2_derivadas_membro2}
	\int_{x_1}^{x_2} \frac{\partial f}{\partial y'}\eta ' dx
	=
	-
	\int_{x_1}^{x_2}
		\frac{d}{dx} \left (
			\frac{\partial f}{\partial y'}
		\right ) \eta dx
	\text{.}
\end{equation}

A terceira parcela deve ser integrada duas vezes por partes. Na primeira integração, seja $u=\dfrac{\partial f}{\partial y''}$ e $dv=\eta''dx$, onde 
$du=\dfrac{d}{dx} \left (
	\dfrac{\partial f}{\partial y''}
\right) dx$ e $v=\eta '$. Assim,
\begin{equation}
	\label{eqn:cap_calc_var:el_diff_2_eta2}
	\int_{x_1}^{x_2}
		\frac{\partial f}{\partial y''}
		\eta ''
	dx
	=
	\frac{\partial f}{\partial y''} \eta ' \Big |_{x_1}^{x_2}
	-
	\int_{x_1}^{x_2} \frac{d}{dx}
		\left ( 
			\frac{\partial f}{\partial y''}
		\right )
	\eta ' dx
	\text{.}
\end{equation}

Integrando, por partes, a segunda parcela de \eqref{eqn:cap_calc_var:el_diff_2_eta2}, tomando $u=\dfrac{d}{dx}\left (\dfrac{\partial f}{\partial y''}\right )$ e $dv=\eta'dx$, de onde $du=\dfrac{d^2}{dx^2}\left ( \dfrac{\partial f}{\partial y''} \right ) dx$ e $v=\eta$. Portanto,
$$
	\int_{x_1}^{x_2}
		\frac{\partial f}{\partial y''}
		\eta'' dx
	=
		\frac{\partial f}{\partial y''}\eta ' \Big |_{x_1}^{x_2}
		- \left [
		\frac{d}{dx} \left (
			\frac{\partial f}{\partial y''}
		\right ) \eta \Big |_{x_1}^{x_2}
		-
		\int_{x_1}^{x_2}
			\frac{d^2}{dx^2} \left (
				\frac{\partial f}{\partial y''}
			\right )
		\eta dx
	\right ]
	\text{,}
$$
e, como $\eta(x_1)=\eta(x_2)=0$,
\begin{equation}
	\label{eqn:cap_calc_var:el_diff_2_eta2_complete}
	\int_{x_1}^{x_2}
		\frac{\partial f}{\partial y''}
		\eta'' dx
	=
	\frac{\partial f}{\partial y''}\eta ' \Big |_{x_1}^{x_2}
	+
	\int_{x_1}^{x_2}
		\frac{d^2}{dx^2} \left (
			\frac{\partial f}{\partial y''}
		\right )
	\eta dx
	\text{.}
\end{equation}

Voltando a \eqref{eqn:cap_calc_var:func_2_derivada_integracao}, e substituindo os valores de \eqref{eqn:cap_calc_var:func_2_derivadas_membro2} e \eqref{eqn:cap_calc_var:el_diff_2_eta2_complete}, tem-se
$$
	I'(0)=
	\int_{x_1}^{x_2}
		\frac{\partial f}{\partial y}
		\eta dx
	-
	\int_{x_1}^{x_2}
		\frac{d}{dx}\left (
			\frac{\partial f}{\partial y'}
		\right ) \eta dx
	+
	\frac{\partial f}{\partial y''}\eta' \Big |_{x_1}^{x_2}
	+
	\int_{x_1}^{x_2}
		\frac{d^2}{dx^2}\left (
			\frac{\partial f}{\partial y''}
		\right ) \eta dx
	\text{,}
$$
de onde, reorganizando os termos e colocando $\eta$ em evidência, e, finalmente, fazendo $I'(0)=0$, obtem-se
\begin{equation}
	\label{eqn:cap_calc_var:cond_with_naturalbound}
	I'(0)=
	\int_{x_1}^{x_2}
	\left (
		\frac{\partial f}{\partial y}
	-
		\frac{d}{dx}\left (
			\frac{\partial f}{\partial y'}
		\right )
	+
		\frac{d^2}{dx^2}\left (
			\frac{\partial f}{\partial y''}
		\right )
	\right ) \eta dx
	+
	\frac{\partial f}{\partial y''}\eta' \Big |_{x_1}^{x_2}
	= 0
	\text{.}
\end{equation}

A segunda parcela de \eqref{eqn:cap_calc_var:cond_with_naturalbound}, $\dfrac{\partial f}{\partial y''}\eta '\Big|_{x_1}^{x_2}$, é uma das chamadas \index[remissivo]{Condições de Contorno Naturais}Condições de Contorno Naturais e deve-se anular para que o funcional se torne estacionário. Porém, o foco nessa parte é tratar a equação de Euler-Lagrange, que é uma condição necessária, mas não suficiente, para que o funcional se torne estacionário. As Condições de Contorno Naturais são tratadas na Seção \ref{sec:cond_contorno}. Devido, então, ao fato de que a mesma deve-se anular, resta que
\begin{equation}
	\label{eqn:cap_calc_var:func_2_derivadas_final}
	I'(0)=
	\int_{x_1}^{x_2}
	\left (
		\frac{\partial f}{\partial y}
	-
		\frac{d}{dx}\left (
			\frac{\partial f}{\partial y'}
		\right )
	+
		\frac{d^2}{dx^2}\left (
			\frac{\partial f}{\partial y''}
		\right )
	\right ) \eta dx
	\text{,}
\end{equation}
onde, utilizando o Lema \ref{lema:cap_calcvar_lema_1} em \eqref{eqn:cap_calc_var:func_2_derivadas_final}, a \index[remissivo]{Equação de Euler-Lagrange}equação de Euler-Lagrange obtida é

\begin{equation}
	\label{eqn:cap_calc_var:eq_euler_lagrange_twodiff}
	\frac{\partial f}{\partial y}
	-
	\frac{d}{dx}\left (
		\frac{\partial f}{\partial y'}
	\right )
	+
	\frac{d^2}{dx^2}\left (
		\frac{\partial f}{\partial y''}
	\right )
	=0 \text{.}
\end{equation}

É importante ressaltar, novamente, que a equação de Euler-Lagrange \eqref{eqn:cap_calc_var:eq_euler_lagrange_twodiff} obtida é uma condição necessária, porém não é condição suficiente para a estacionariedade do funcional.

\subsection{Equação geral}

Para a obtenção da Equação Geral, para funcionais que dependem de derivadas até a ordem $n$, o processo para a obtenção da equação de Euler-Lagrange é análogo. Em \eqref{eqn:cap_calc_var:func_n_derivadas_pos_separar} deve-se integrar a segunda parcela por partes uma vez, a terceira parcela duas vezes, a quarta parcela três vezes e assim por diante, até que a $n$-ésima parcela seja integrada $n-1$ vezes, também por partes. Ao fim do processo, a \index[remissivo]{Equação de Euler-Lagrange}equação de Euler-Lagrange será obtida fazendo $I'(0)=0$, isto é, aplicando a condição de estacionariedade e, por último, utilizando o Lema \ref{lema:cap_calcvar_lema_1}. Deste modo, a equação encontrada é

\begin{equation}
	\label{eqn:cap_calc_var:euler_lagrange_nesimo}
	\frac{\partial f}{\partial y}
	- \frac{d}{dx}\left ( \frac{\partial f}{\partial y'} \right )
	+ \frac{d^2}{dx^2}\left ( \frac{\partial f}{\partial y''} \right )
	- \frac{d^3}{dx^3}\left ( \frac{\partial f}{\partial y'''} \right )
	+ \cdots
	+ (-1)^n \frac{d^n}{dx^n}\left (\frac{\partial f}{\partial y^{(n)}} \right )
	= 0
	\text{.}
\end{equation}

A equação \eqref{eqn:cap_calc_var:euler_lagrange_nesimo} é escrita, também, como
$$
	\sum_{i=0}^n (-1)^i\frac{d^i}{dx^i}\left (
		\frac{\partial f}{\partial y^{(i)}}
	\right )
	= 0
	\text{,}
$$
onde a primeira parcela, $\dfrac{d^0}{dx^0} \left ( \dfrac{\partial f}{\partial y^0} \right )$, representa $\dfrac{\partial f}{\partial y}$.

%{\color{red}Durante o processo para a obtenção da equação de Euler-Lagrange, (...)}

%Durante o processo para a obtenção dos extremos de um funcional, donde se deduz a equação de Euler-Lagrange, como nas seções \ref{sec:eq_euler_lagrange} e \ref{sec:eq_euler_lagrange_superior}, surgem algumas condições de contorno, como, por exemplo, o termo
%$$
%	\frac{\partial f}{\partial y'}\eta \Big |_{x_1}^{x_2}
%	=0
%$$
%na equação \eqref{eqn:cap_calc_var:integration_parts}.

%Durante o processo de encontrar um extremo para um funcional, surgem algumas condições de contorno... {\color{red}(Escrever sobre).}

\section{Exemplos}
\label{sec:calcvar_exemplos}

\begin{exemplo}[Curva de Menor Comprimento entre Dois Pontos]
	É sabido, do cálculo diferencial e integral, que o comprimento, $I$, de uma curva $y(x)$ é determinado por
	\begin{equation}
		\label{eqn:ex_reta_funcional}
		I=\int_{x_1}^{x_2}\sqrt{1+(y'(x))^2}dx
		\text{,}
	\end{equation}
	que é um funcional que depende de $y'(x)$. Assim, pode-se determinar a curva $y(x)$ que minimiza o funcional, ou seja, encontrar a menor curva entre dois pontos dados onde $x_1$ e $x_2$ são as abcissas do primeiro e do segundo ponto, respectivamente.
\end{exemplo}

\begin{solution}
	Como o funcional de \eqref{eqn:ex_reta_funcional} depende apenas de $y'(x)$, sua equação de Euler-Lagrange será da forma
	\begin{equation}
		\label{eqn:ex_reta_eq_euler_lagrange}
		\frac{\partial f}{\partial y}
		-
		\frac{d}{dx} \left (
			\frac{\partial f}{\partial y'}
		\right )
		= 0
		\text{,}
	\end{equation}
	onde $f(x, y, y')=\sqrt{1+(y'(x))^2}$.
	
	De \eqref{eqn:ex_reta_eq_euler_lagrange}, fazendo as devidas derivações, tem-se a equação
	\begin{equation}
		\label{eqn:ex_reta_prim_deriv}
		-\frac{d}{dx} \left (
			\frac{y'(x)}{\sqrt{1+(y'(x))^2}}
		\right )
		= 0
		\text{,}
	\end{equation}
	de onde tem-se
	$$
		\frac{
			y''(x)\sqrt{1+(y'(x))^2}
			-
			y'(x)\left (
				\frac{y'(x)y''(x)}{\sqrt{1+(y'(x))^2}}
			\right )
		}{
			1+(y'(x))^2
		}
		=0\text{,}
	$$
	e, devido ao fato de que o denominador $1+(y'(x))^2\geqslant 1$, pode-se analisar apenas o numerador, ou seja,
	$$
		y''(x)\sqrt{1+(y'(x))^2}
		-
		\frac{(y'(x))^2 y''(x)}{
			\sqrt{1+(y'(x))^2}
		}
		= 0
	$$
	$$
		\frac{
			y''(x)(1+(y'(x))^2)-(y'(x))^2y''(x)
		}{
			\sqrt{1+(y'(x))^2}
		}
		= 0
		\text{,}
	$$
	resultando, após manipulações no numerador, em
	$$
		\frac{y''(x)}{
			\sqrt{1+(y'(x))^2}
		}
		= 0
		\text{,}
	$$
	e, finalmente, $y''(x)=0$.
	
	A equação diferencial $y''(x)=0$ pode ser resolvida por meio de integrações sucessivas
	$$
		\int y''(x)dx = \int 0 dx \Longrightarrow y'(x) = C_1
	$$
	$$
		\int y'(x)dx = \int C_1 dx \Longrightarrow y(x) = C_1 x + C_2
		\text{,}
	$$
	ou seja, $y(x)=C_1x+C_2$. Deste modo, a curva de menor comprimento entre os dois pontos é um segmento de reta.
\end{solution}

\begin{exemplo}
	\label{ex:cond_contorno}\cite{mefassan}
	Considere o funcional de energia potencial de uma viga dado por
	\begin{equation}
		\label{eqn:cap_calc_var:funcional_pi}
		\Pi = \frac{1}{2}	\int_{0}^{l}
			EI \left (
				\frac{d^2v}{dx^2}
			\right )^2 dx
			-
			\int_{0}^{l} qv dx
			\text{,}
	\end{equation}
	onde $E$ é o módulo de Young do material, $I$ é o momento de inércia da seção transversal da viga em relação ao eixo baricêntrico, $l$ é o comprimento da viga e $q$ é a carga distribuída de forma uniforme sobre a viga. Encontre $v(x)$ de modo que $I$ seja estacionário, com as condições de contorno essenciais, $v(0)=0$ e $v(l)=0$, e as condições de contorno naturais $\dfrac{d^2v}{dx^2}\Big |_{x=0}$ e $\dfrac{d^2v}{dx^2}\Big |_{x=l}$.
\end{exemplo}
\begin{solution}
	A determinação de $v(x)$ pode ser feita diretamente utilizando a equação de Euler-Lagrange (Ver Seção \ref{sec:eq_euler_lagrange}), porém, aqui será repetido o processo, mostrando que as condições de contorno naturais realmente surgem durante o processo de obtenção da equação. Variando $v$ por $\overline{v}_{\varepsilon}=v+\varepsilon \eta$ em \eqref{eqn:cap_calc_var:funcional_pi}, tem-se
	$$
		\Pi(\varepsilon) = \frac{1}{2} \int_{0}^{l}
			EI \left (
				\frac{d^2\overline{v}}{dx^2}
			\right )^2 dx
			-
			\int_{0}^{l} q\overline{v} dx
			\text{,}
	$$
	de onde, derivando $I(\varepsilon)$ em relação a $\varepsilon$, resulta em
	\begin{equation}
		\label{eqn:cap_calc_var:natural_conditions_deduce}
		\frac{d\Pi}{d\varepsilon} = 
			\int_{0}^{l} EI \left (
				\frac{d^2\overline{v}}{dx^2}
			\right ) \cdot 
			\frac{d}{d\varepsilon}\left (
				\frac{d^2\overline{v}}{dx^2}
			\right ) dx
			-
			\int_{0}^{l} q\frac{d\overline{v}}{d\varepsilon} dx
			\text{.}
	\end{equation}
	
	Manipulando \eqref{eqn:cap_calc_var:natural_conditions_deduce}, e calculando $\dfrac{d\Pi}{d\varepsilon}\Big |_{\varepsilon=0}$, pois $\overline{v}$ pode ser substituido por $v$, naturalmente, chega-se a
	$$
		\frac{d\Pi}{d\varepsilon}\Big |_{\varepsilon=0} = 
			\int_{0}^{l} EI \left (
				\frac{d^2v}{dx^2}
			\right ) \left (
				\frac{d^2\eta}{dx^2}
			\right ) dx
			-
			\int_{0}^{l}q\eta dx
		\text{,}
	$$
	onde a primeira parcela deve ser integrada, por partes, duas vezes, resultando em
	\begin{equation}
		\label{eqn:cap_calc_var:natural_conditions_I0}
		\frac{d\Pi}{d\varepsilon}\Big |_{\varepsilon=0} = 
			\int_{0}^{l} \left (
				EI\frac{d^4 v}{dx^4}-q 
			\right ) \eta dx
			+
			EI\frac{d^2 v}{dx^2} \eta' \Big |_{0}^{l}
			-
			EI\frac{d^3 v}{dx^3} \eta \Big |_{0}^{l}
			\text{.}
	\end{equation}
	
	Aplicando a condição de estacionariedade, $\dfrac{d\Pi}{d\varepsilon}\Big |_{\varepsilon=0}=0$, em \eqref{eqn:cap_calc_var:natural_conditions_I0},
	\begin{equation}
		\label{eqn:cap_calc_var:natural_conditions_I0_eq_0}
		\frac{d\Pi}{d\varepsilon}\Big |_{\varepsilon=0} = 
			\int_{0}^{l} \left (
				EI\frac{d^4 v}{dx^4}-q 
			\right ) \eta dx
			+
			EI\frac{d^2 v}{dx^2} \eta ' \Big |_{0}^{l}
			-
			EI\frac{d^3 v}{dx^3} \eta \Big |_{0}^{l}
			= 0
			\text{.}
	\end{equation}

	É preciso, então, que os termos de \eqref{eqn:cap_calc_var:natural_conditions_I0_eq_0} se anulem. A primeira parcela de \eqref{eqn:cap_calc_var:natural_conditions_I0_eq_0} resulta na equação de Euler-Lagrange
	\begin{equation}
		\label{eqn:cap_calc_var:natural_eq_euler_lagr}
		EI\frac{d^4v}{dx^4} - q = 0
		\text{,}
	\end{equation}
	enquanto que as duas outras parcelas são as condições de contorno naturais do problema
	\begin{equation}
		\label{eqn:cap_calc_var:natural_cond1}
		\frac{d^2 v}{dx^2}\Big |_{x=0} = 0
		\text{,}
	\end{equation}
	\begin{equation}
		\label{eqn:cap_calc_var:natural_cond1_l}
		\frac{d^2 v}{dx^2}\Big |_{x=l} = 0
		\text{,}
	\end{equation}
	\begin{equation}
		\label{eqn:cap_calc_var:natural_cond2}
		\frac{d^3 v}{dx^3}\Big |_{x=0} = 0
		\text{,}
	\end{equation}
	\begin{equation}
		\label{eqn:cap_calc_var:natural_cond2_l}
		\frac{d^3 v}{dx^3}\Big |_{x=l} = 0
		\text{.}
	\end{equation}

	A equação de Euler-Lagrange \eqref{eqn:cap_calc_var:natural_eq_euler_lagr} pode ser facilmente resolvida, isolando $\dfrac{d^4 v}{dx^4}$ e integrando ambos os lados da equação quatro vezes seguidas. Ao final desse processo, a função $v$ encontrada será
	\begin{equation}
		\label{eqn:cap_calc_var:natural_funcao_v}
		v(x)=\frac{q}{24EI}x^4 + \frac{C_1}{6}x^3 + \frac{C_2}{2}x^2 + C_3x + C_4
		\text{,}
	\end{equation}
	onde os coeficientes $C_1$, $C_2$, $C_3$ e $C_4$ podem ser determinados através do uso das condições de contorno naturais e essenciais.

	Da condição de contorno essencial, $v(0)=0$, resulta que o coeficiente $C_4=0$. Aplicando, então as condições de contorno naturais \eqref{eqn:cap_calc_var:natural_cond1}, tem-se
	$$
		\left (
			\frac{q}{2EI}x^2 + C_1x + C_2
		\right ) \Big |_{x=0}
		= 0
		\text{,}
	$$
	resultando no valor do coeficiente $C_2=0$. Utilizando o outro extremo de \eqref{eqn:cap_calc_var:natural_cond1}, tem-se
	$$
		\left (
			\frac{q}{2EI}x^2 + C_1x + C_2
		\right ) \Big |_{x=l}
		=0
		\text{,}
	$$
	onde
	$$
		\frac{ql^2}{2EI}+C_1l=0
		\text{,}
	$$
	resultando em $C_1=-\dfrac{ql}{2EI}$.

	Para o último coeficiente, $C_3$, será utilizado a outra condição de contorno essencial, $v(l)=0$,
	$$
		\frac{q}{24EI}l^4
		-
		\frac{ql^4}{12EI}
		+
		C_3l
		= 0
		\text{,}
	$$
	tendo, assim, como resultado, $C_3=\dfrac{ql^3}{24EI}$.

	Substituindo, então, os coeficientes $C_1$, $C_2$, $C_3$ e $C_4$ determinados na função $v(x)$, encontrada em \eqref{eqn:cap_calc_var:natural_funcao_v},
	\begin{equation}
	\label{eqn:sol_funcional_analitico}
	v(x) = 
		\frac{q}{24EI} x^4
		-
		\frac{ql}{12EI} x^3
		+
		\frac{ql^3}{24EI} x
		\text{.}
	\end{equation}
\end{solution}

\chapter{MÉTODO DE RAYLEIGH-RITZ}
\label{cap:mrr}

Um dos objetivos do cálculo variacional é encontrar uma função $y(x)$ que, dentre as funções admissíveis torna o funcional estacionário. Uma das formas para se encontrar a função $y(x)$ é encontrando a Equação de Euler-Lagrange, ver Seção \ref{sec:eq_euler_lagrange} e \ref{sec:eq_euler_lagrange_superior} do Capítulo \ref{cap:calc_var}, associada ao problema e, então, resolvê-la. 

A resolução de equações diferenciais e a determinação da solução exata por meio das condições de contorno do problema é, entretanto,  uma tarefa trabalhosa e, em muitos casos, até não factível. Para se esquivar de problemas como esses, surgem alguns métodos, dentre os quais está o método de Rayleigh-Ritz.

As explicações e os conceitos aqui utilizados foram elaboradas tomando como referências os autores \citeonline{mefassan} e \citeonline{MRR_Deflex}.

O \index[remissivo]{Método de Rayleigh-Ritz}método de Rayleigh-Ritz propõe que a função $y(x)$, exata, seja substituída por uma função aproximada $v(x)$ que é formada pela combinação linear de funções $\phi _i(x)$. Uma das vantagens do uso do método é que ele não requer que as condições de contorno naturais sejam satisfeitas \cite{GROSSI_2001}. Deste modo, o método é empregado principalmente em problemas onde as condições de contorno naturais são de difícil resolução.

Considerando o funcional
$$
	I=\int_{x_1}^{x_2} f(x,y,y',\dots,y^{(m)})dx
	\text{,}
$$
com as condições de contorno $y(x_1)=y(x_2)=0$, então a função $y(x)$ é aproximada por meio da função $v(x)$ definida como
$$
	v(x) = \sum_{i=1}^n a_i \phi _i (x)
	\text{,}
$$
onde os coeficientes $a_i \in \mathbb{R}$ são chamados de \index[remissivo]{Parâmetros de Deslocamento}parâmetros de deslocamento, as funções $\phi_i(x)$ são chamadas de \index[remissivo]{Função de Forma}funções de forma e devem ser linearmente independentes. As funções $\phi_i(x)$ devem ser, também, diferenciáveis até a ordem $m$, onde $m$ é a ordem da maior derivada do funcional. A função $v(x)$ é chamada de \index[remissivo]{Função Aproximadora}função aproximadora.

Substituindo $y$ por $v$ no funcional, $I$ passa a ser uma função de $a_1$, $a_2$, $\dots$, $a_n$, isto é, $I=I(a_1, a_2, \dots, a_n)$. A condição de máximo ou mínimo para o funcional $I$ é, então, que as suas derivadas parciais em relação a $a_1$, $a_2$, $\dots$, $a_n$ se anulem, ou seja
$$
	\frac{\partial I}{\partial a_i} = 0
	\text{,}
$$
com $i=1, 2, 3, \dots, n$.

\begin{exemplo}
	\label{ex:mrr_ex_livro}\cite{mefassan}		
	A viga prismática da Figura \ref{fig:test_02} possui o funcional de energia potencial total associado
	\begin{equation}
		\label{eqn:cap_metodo_ray_ritz:exemplo_func_pi}
		\Pi = 
		\frac{1}{2} \int_0^l EI \left [
			\frac{d^2v}{dx^2}
		\right ]^2 dx
		-
		\int_0^l qvdx
		\text{,}
	\end{equation}
	onde $E$ é o módulo de Young do material, $I$ é o momento de inércia da seção transversal da viga em relação ao eixo baricêntrico, $l$ é o comprimento da viga e $q$ é a carga distribuída de forma uniforme sobre a viga.
	
	\begin{figure}[h]
		\caption{Viga prismática.}
		\centering
		\begin{tikzpicture}
			\tkzInit[xmin=-0, xmax=6, ymin=-0.6, ymax=2]
			% draw axis without ticks
			\tkzDrawX[label=$x$, noticks, loosely dashed]
			\tkzDrawY[label=$v(x)$, noticks]
			
			% rectangle
			\tkzDefPoints{
				0/0.6/V_1,
				5/0.6/V_2,
				5/-0.6/V_3,
				0/-0.6/V_4}
			% complete x axis without dashed line
			\tkzDefPoints{
				5/0/A_1,
				6.35/0/A_2}
			% left base triangle
			\tkzDefPoints{
				0/-0.6/T1_1, 
				-0.25/-1.1/T1_2, 
				0.25/-1.1/T1_3}
			% right base triangle
			\tkzDefPoints{
				5/-0.6/T2_1, 
				4.75/-1.1/T2_2,
				5.25/-1.1/T2_3}
			% line on base of right triangle
			\tkzDefPoints{
				4.75/-1.2/T2_B1,
				5.25/-1.2/T2_B2}
			% length marker in bottom
			\tkzDefPoints{
				0/-1.5/L_1,
				0/-2/L_2,
				5/-1.5/L_3,
				5/-2/L_4,
				0/-1.75/LS_1,
				5/-1.75/LS_2}
			
			\tkzDrawSegment[color=black, line width=0.5mm](A_1, A_2)
			
			\tkzDrawPolygon[draw=black](T1_1, T1_2, T1_3)
			\tkzDrawPolygon[draw=black](T2_1, T2_2, T2_3)
			\tkzDrawSegment[color=black](T2_B1, T2_B2)
			\tkzDrawPolygon[draw=black](V_1, V_2, V_3, V_4)
			% q arrows
			\foreach \i in {1,...,25}{
				\tkzDefPoint(0.2*\i,1.3){A_\i}
				\tkzDefPoint(0.2*\i,0.7){B_\i}
				\draw[line width=0.6pt, black,-stealth] (A_\i) -- (B_\i);
			}
			% q text
			\node at (2.5,1.7) {$q$};
			% length marker in bottom
			\tkzDrawSegment[color=black](L_1, L_2)
			\tkzDrawSegment[color=black](L_3, L_4)
			\tkzDrawSegment[color=black](LS_1, LS_2)
			\node at (2.5,-2) {$l$};
		\end{tikzpicture}
		\label{fig:test_02}	
		\legend{\ABNTEXfontereduzida Fonte: \citeonline[p. 25]{mefassan}.}
		%\legend{\ABNTEXfontereduzida Fonte: Elaborada pelo autor, 2019.}
	\end{figure}
	
	Utilize o método o método de Rayleigh-Ritz para aproximar a função exata $v(x)$ através de funções polinomiais de grau 2, 3 e 4 de modo que o funcional \eqref{eqn:cap_metodo_ray_ritz:exemplo_func_pi} se torne estacionário.
\end{exemplo}

\begin{solution}
	É possível encontrar uma função que aproxime a função exata $v(x)$ tornando o funcional \eqref{eqn:cap_metodo_ray_ritz:exemplo_func_pi} estacionário utilizando o método de Rayleigh-Ritz. Esse processo será feito utilizando três funções aproximadoras:
	\noEquationSpacing
	{
		\begin{equation}
			\label{eqn:cap_metodo_ray_ritz_funcdef_v1}
			v_1 (x) = a_0 + a_1 x + a_2 x^2
			\text{,}
		\end{equation}
		\begin{equation}
			\label{eqn:cap_metodo_ray_ritz_funcdef_v2}
			v_2 (x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3
			\text{,}
		\end{equation}
		\begin{equation}
			\label{eqn:cap_metodo_ray_ritz_funcdef_v3}
			v_3 (x) = a_0 + a_1 x + a_2 x^2 + a_3 x^3 + a_4 x^4
			\text{.}
		\end{equation}
	}
	
	Para parâmetro de comparação com os resultados apresentados pelas funções $v_1(x)$, $v_2(x)$ e $v_3(x)$ definidas em \eqref{eqn:cap_metodo_ray_ritz_funcdef_v1}, \eqref{eqn:cap_metodo_ray_ritz_funcdef_v2} e \eqref{eqn:cap_metodo_ray_ritz_funcdef_v3}, será utilizado o valor de máxima deflexão da Viga da Figura \ref{fig:test_02}. Esse valor foi determinado no Apêndice \ref{apend:max_deflex}, em \eqref{eqn:max_deflex_resultado}, como
	\begin{equation}
		\label{eqn:cap_metodo_ray_ritz:ex1_max_deflex_exato}
		v\left (\frac{l}{2} \right)=\frac{5ql^4}{384EI}
		\text{,}
	\end{equation}
	
	Como primeira aproximação, pode-se utilizar a função $v_1(x)=a_0+a_1x+a_2x^2$, de onde, considerando as condições de contorno essenciais, tem-se que $v_1(0)=0$, levando a $a_0=0$, e de $v_1(l)=0$, concluindo que $a_1=-a_2l$. Assim, a função é escrita como
	$$
		v_1(x)=a_2(x^2-lx)
		\text{.}
	$$
	
	Sua derivada é $v_1'(x)=a_2(2x-l)$ e, a derivada de segunda ordem é $v_1''(x)=2a_2$. Substituindo esses valores no funcional \eqref{eqn:cap_metodo_ray_ritz:exemplo_func_pi}, tem-se que
	$$
		\Pi =
		\frac{1}{2}
		\int_0^l 4 EI a_2 ^2 dx
		-
		\int_0^l q a_2 (x^2-lx) dx
		\text{.}
	$$
	
	Da condição de estacionariedade tem-se, que $\dfrac{\partial \Pi}{\partial a_2} = 0$ e, consequentemente
	$$
		\frac{\partial \Pi}{\partial a_2}
		=
		\frac{\partial}{\partial a_2} \left [
			\int_0^l \left ( 2EIa_2 ^2 - a_2 q (x^2 -lx) \right ) dx
		\right]
		= 0
	$$
	$$
		\frac{\partial \Pi}{\partial a_2}
		=
		\int_0^l
			\frac{\partial}{\partial a_2} \left [
			2EIa_2^2 - a_2 q(x^2-lx)
		\right ] dx
		= 0
	$$
	$$
		\frac{\partial \Pi}{\partial a_2}
		=
		\int_0^l \left [
			4EIa_2 - q(x^2-lx)
		\right ] dx
		= 0
	$$
	$$
		\left [ 
			4EIa_2 x \Big |_0^l
			-
			q \left (
				\frac{x^3}{3} - \frac{lx^2}{2}
			\right ) \Big |_0^l
		\right ] 
		= 0
	$$
	$$
		4EIa_2l
		-
		q \left (\frac{l^3}{3} - \frac{l^3}{2} \right )
		= 0
	$$	
	$$
		4EIa_2l+\frac{ql^3}{6} = 0
	$$
	$$
		a_2=\frac{-ql^2}{24EI}\text{.}
	$$

	Com o valor de $a_2$ conhecido, é possível determinar o valor de $a_1=-a_2l$, resultando em
	$$
		a_1=\frac{ql^3}{24EI}
		\text{.}
	$$
	
	Assim, a função aproximadora $v_1$ pode ser escrita como
	$$
		v_1(x)=
		\frac{ql^3}{24EI}x
		-
		\frac{ql^2}{24EI}x^2
		\text{.}
	$$
	
	Calculando $v_1(\frac{l}{2})$ a título de comparação com o valor exato de máxima deflexão da viga, dado por \eqref{eqn:cap_metodo_ray_ritz:ex1_max_deflex_exato},
	\begin{equation}
		\label{eqn:cap_metodo_ray_ritz:ex1_max_deflex_apv1}
		v_1\left (\frac{l}{2} \right) = \frac{ql^4}{96EI}
		\text{.}
	\end{equation}
	
	Note que há uma grande diferença entre o valor encontrado pela função $v_1(x)$, \eqref{eqn:cap_metodo_ray_ritz:ex1_max_deflex_apv1}, e o valor exato, \eqref{eqn:cap_metodo_ray_ritz:ex1_max_deflex_exato}. Visando uma melhoria nessa aproximação, faz-se necessário o uso da função definida $v_2(x)=a_0+a_1x+a_2x^2+a_3x^3$. Das condições de contorno essenciais, $v_2(0)=0$, de onde $a_0=0$, e $v_2(l)=0$, isolando $a_1=-a_2 l - a_3 l^2$. Assim, a função $v_2(x)$ é
	\begin{equation}
		\label{eqn:cap_metodo_ray_ritz:v2_organizada}
		v_2(x)=
		a_2(x^2-lx)
		+
		a_3(x^3-l^2x)
		\text{.}
	\end{equation}
	
	Derivando a função $v_2$ em função de $x$, duas vezes, pode-se obter
	
	\noEquationSpacing
	{
		$$
		v_2'(x) = a_2(2x-l) + a_3(3x^2-l^2)
		$$
		\begin{equation}
			\label{eqn:cap_metodo_ray_ritz:v2_diff_organizada}
			v_2''(x) = 2a_2 + 6a_3 x \text{.}
		\end{equation}
	}
	
	Substituindo \eqref{eqn:cap_metodo_ray_ritz:v2_organizada} e \eqref{eqn:cap_metodo_ray_ritz:v2_diff_organizada} em $\Pi$, tem-se
	$$
		\Pi=
		\frac{1}{2}
		\int_0^l
			\left (
				EI(2a_2+6a_3x)^2
			\right ) dx
		-
		\int_0^l
			q
			\left (
				a_2(x^2-lx)
				+
				a_3(x^3-l^2x)
			\right ) dx
		\text{.}
	$$
	
	Derivando $\Pi$ em função de $a_2$ é possível obter
	$$
		\frac{\partial \Pi}{\partial a_2}
		=
		\int_0^l \left [
			2EI(2a_2+6a_3x)-q(x^2-lx)
		\right ] dx
		= 0
	$$	
	$$
		\frac{\partial \Pi}{\partial a_2}
		=
		\int_0^l \left [
			EI(4a_2+12a_3x)-q(x^2-lx)
		\right ] dx
		= 0
	$$
	$$
		\int_0^l \left [
			4EIa_2 + 12EIa_3x - qx^2 + qlx
		\right ] dx
		= 0
	$$
	$$
		4EIa_2 x \Big |_0^l
		+
		\frac{12a_3EI}{2} x^2 \Big |_0^l
		-
		\frac{q}{3} x^3 \Big |_0^l
		+
		\frac{ql}{2} x^2 \Big |_0^l
		= 0
	$$
	$$
		4EIa_2l
		+
		6a_3EIl^2
		=
		\frac{2ql^3}{6}
		-
		\frac{3ql^3}{6}
	$$
	$$
		4a_2 + 6a_3l
		=
		\frac{-ql^2}{6EI}
	$$
	\begin{equation}
		\label{eq:exemp_rayritz_approx2_eq1}
		2a_2 + 3a_3l
		=
		\frac{-ql^2}{12EI}
		\text{.}
	\end{equation}
	
	Derivando $\Pi$ em relação a $a_3$ tem-se que
	$$
		\frac{\partial \Pi}{\partial a_3}
		=
		\int_0^l \left [
			6EI(2a_2 + 6a_3x)x
			-
			q(x^3 - l^2x)
		\right ] dx
		= 0
	$$
	$$
		\int_0^l \left [
			EI(12a_2 + 36a_3x)x
			-
			q(x^3 - l^2x)
		\right ] dx
		= 0
	$$
	$$
		\int_0^l \left [
			EI(12a_2 x + 36a_3x^2)
			-
			q(x^3 - l^2x)
		\right ] dx = 0
		= 0
	$$
	$$
		EI \left (
			\frac{12a_2}{2}x^2 \Big |_0^l
			+
			\frac{36a_3}{3}x^3 \Big |_0^l
		\right )
		-
		q \left (
			\frac{x^4}{4} \Big |_0^l
			-
			\frac{l^2x^2}{2} \Big |_0^l
		\right )
		= 0
	$$
	$$
		EI(6a_2l^2 + 12a_3l^3)
		-
		q \left (
			\frac{l^4}{4}
		\right )
		+
		q \left (
			\frac{l^4}{2}
		\right )
		=0
	$$
	$$
		6a_2 + 12a_3l = -\frac{ql^4}{4EIl^2}
	$$
	\begin{equation}
		\label{eq:exemp_rayritz_approx2_eq2}
		2a_2 + 4a_3l = -\frac{ql^2}{12EI}
		\text{.}
	\end{equation}
	
	Montando um sistema de equações com \eqref{eq:exemp_rayritz_approx2_eq1} e \eqref{eq:exemp_rayritz_approx2_eq2}:
	\begin{equation}
		\label{eqn:ex_rayritz_sistema_2}
		\begin{cases}
			2a_2+3a_3l=\dfrac{-ql^2}{12EI}\\[10pt]
			2a_2+4a_3l=\dfrac{-ql^2}{12EI}
		\end{cases}
	\end{equation}
	é possível encontrar os valores de $a_2$ e $a_3$. 
	
	Subtraindo as equações em \eqref{eqn:ex_rayritz_sistema_2}, tem-se
	$$
		4a_3l-3a_3l=-\frac{ql^2}{12EI}+\frac{ql^2}{12EI}
	$$
	$$
		a_3=0\text{.}
	$$
	
	Consequentemente,
	$$
		a_2=-\frac{ql^2}{24EI}
		\text{.}
	$$

	Assim, a função $v_2(x)$ é a mesma que $v_1(x)$, não permitindo uma melhoria na aproximação desejada, sendo, portanto, inútil para esse caso. Ainda, visando melhor aproximação, deve-se passar para a próxima função aproximadora escolhida, $v_3(x)$.
	
	Utilizando a função $v_3(x)=a_0+a_1x+a_2x^2+a_3x^3+a_4x^4$, tem-se das condições de contorno essensiais que $v_3(0)=0$, donde $a_0=0$ e, $v_3(l)=0$, isto é $a_1l+a_2l^2+a_3l^3+a_4l^4=0$, donde pode-se concluir que $a_1=-a_2l-a_3l^2-a_4l^3$. Substituindo $a_0$ e $a_1$ em $v_3(x)$, podemos encontrar a função
	\begin{equation}
		\label{eqn:cap_metodo_ray_ritz:func_def_v3}
		v_3(x)=
		a_2 (x^2 - lx)
		+
		a_3 (x^3 - l^2x)
		+
		a_4 (x^4 - l^3x)
		\text{.}
	\end{equation}
	
	Derivando $v_3$ em relação a $x$, duas vezes:
	$$
		v_3'(x)=
		a_2(2x - l)
		+
		a_3(3x^2 - l^2)
		+
		a_4(4x^3 - l^3)
	$$
	\begin{equation}
		\label{eqn:cap_metodo_ray_ritz:func_def_v3_diff}
		v_3''(x)=
		2a_2
		+
		6a_3 x
		+
		12a_4 x^2
		\text{.}
	\end{equation}
	
	Substituindo \eqref{eqn:cap_metodo_ray_ritz:func_def_v3} e \eqref{eqn:cap_metodo_ray_ritz:func_def_v3_diff} em $\Pi$,
	$$
		\Pi = \frac{1}{2} \int_0^l \left [
			EI(2a_2+6a_3x+12a_4x^2)^2
		\right ] dx
		-
		\int_0^l q \left [
			a_2(x^2 - lx)
			+
			a_3(x^3 - l^2x)
			+
			a_4(x^4 - l^3x)
		\right ] dx
		\text{,}
	$$
	de onde pode-se derivar $\Pi$ em relação a $a_2$, $a_3$ e $a_4$ para obter um sistema de equações permitindo a determinação de $a_2$, $a_3$ e $a_4$.
	
	Fazendo $\dfrac{\partial \Pi}{\partial a_2} = 0$:
	\begin{equation}
		\label{eqn:cap_metodo_ray_ritz:exemp_v3_diff_a2}
		\frac{\partial \Pi}{\partial a_2}
		=
		\int_0^l \left [
			2EI(2a_2 + 6a_3x + 12a_4x^2)
			-
			q(x^2 - lx)
		\right ] dx
		= 0
	\end{equation}
	$$
		\int_0^l \left [
			EI(4a_2 + 12a_3x + 24a_4x^2)
			-
			q(x^2 - lx)
		\right ] dx
		= 0
	$$
	$$
		EI \left (
			4a_2 x \Big |_0^l
			+
			\frac{12a^3}{2}x^2 \Big |_0^l
			+
			\frac{24a_4}{3}x^3 \Big |_0^l
		\right )
		- q
		\left (
			\frac{x^3}{3} \Big |_0^l
			-
			\frac{lx^2}{2} \Big |_0^l
		\right )
		= 0
	$$
	$$
		EI(4a_2l + 6a_3l^2 + 8a_4l^3)
		=
		\frac{ql^3}{3}
		-
		\frac{ql^3}{2}
	$$
	$$
		4a_2l + 6a_3l^2 + 8a_4l^3 = -\frac{ql^3}{6EI}
	$$
	\begin{equation}
		\label{eq:exemp_rayritz_approx3_eq1}
		2a_2 + 3a_3l + 4a_4l^2 = -\frac{ql^2}{12EI}
		\text{.}
	\end{equation}
		
	Fazendo $\dfrac{\partial \Pi}{\partial a_3} = 0$, tem-se
	\begin{equation}
		\label{eqn:cap_metodo_ray_ritz:exemp_v3_diff_a3}
		\frac{\partial \Pi}{\partial a_3}
		=
		\int_0^l \left [
			6xEI(2a_2 + 6a_3x + 12a_4x^2)
			-
			q(x^3 - l^2x)
		\right ] dx
		= 0
	\end{equation}
	
	$$
		\frac{\partial \Pi}{\partial a_3}
		=
		\int_0^l \left [
			EI(12 a_2 x + 36 a_3 x^2 + 72 a_4 x^3)
			-
			q(x^3-l^2x)
		\right ] dx
		= 0
	$$
	
	$$
		EI \left (
			\frac{12a_2}{2} x^2 \Big |_0^l
			+
			\frac{36a_3}{3} x^3 \Big |_0^l
			+
			\frac{72a_4}{4} x^4 \Big |_0^l
		\right )
		-
		q \left (
			\frac{x^4}{4} \Big |_0^l
			-
			\frac{l^2 x}{2} \Big |_0^l
		\right )
		= 0
	$$
	
	$$
		EI(6a_2 l^2 + 12a_3 l^3 + 18a_4 l^4)
		=
		\frac{ql^4}{4}
		-
		\frac{ql^4}{2}
	$$
	
	$$
		EI(6a_2 l^2 + 12a_3 l^3 + 18a_4 l^4)
		=
		-\frac{ql^4}{4}
	$$
	
	$$
		6a_2 + 12a_3 l + 18a_4 l^2
		=
		-\frac{ql^2}{4EI}
	$$
	
	\begin{equation}
		\label{eq:exemp_rayritz_approx3_eq2}
		a_2 + 2a_3 l + 3a_4 l^2 = - \frac{ql^2}{24EI}
		\text{.}
	\end{equation}
	
	Por último, fazendo $\dfrac{\partial \Pi}{\partial a_4}=0$, tem-se
	
	\begin{equation}
		\label{eqn:cap_metodo_ray_ritz:exemp_v3_diff_a4}
		\frac{\partial \Pi}{\partial a_4}
		=
		\int_0^l \left [
			12x^2EI(2a_2 + 6a_3x + 12a_4x^2)
			-
			q(x^4 - l^3x)
		\right ] dx
		= 0
	\end{equation}
	
	$$
		\int_0^l \left [
			EI(24a_2 x^2 + 72 a_3 x^3 + 144 a_4 x^4)
			-
			q(x^4 - l^3 x)
		\right ] dx
		= 0
	$$
	
	$$
		EI \left ( 
			\frac{24a_2}{3}x^3 \Big |_0^l
			+
			\frac{72a_3}{4}x^4 \Big |_0^l
			+
			\frac{144a_4}{5}x^5 \Big |_0^l
		\right )
		-
		q \left (
			\frac{x^5}{5} \Big |_0^l
			-
			\frac{l^3x^2}{2} \Big |_0^l
		\right )
		= 0
	$$
	
	$$
		EI \left (
			8a_2 l^3 + 18 a_3 l^4 + \frac{144}{5} a_4 l^5
		\right )
		=
		\frac{ql^5}{5}
		-
		\frac{ql^5}{2}
	$$
	
	$$
		EI \left (
			8a_2 l^3 + 18 a_3 l^4 + \frac{144}{5} a_4 l^5
		\right )
		=
		-\frac{3ql^5}{10}
	$$
	
	$$
		8a_2 l^3 + 18 a_3 l^4 + \frac{144}{5} a_4 l^5
		=
		-\frac{3ql^5}{10EI}
	$$
	
	\begin{equation}
		\label{eq:exemp_rayritz_approx3_eq3}
		8a_2 + 18a_3 l + \frac{144}{5} a_4 l^2 
		=
		-\frac{3ql^2}{10EI}
		\text{.}
	\end{equation}
	
	É obtido, assim, um sistema linear de 3 equações em 3 incógnitas, com \eqref{eq:exemp_rayritz_approx3_eq1}, \eqref{eq:exemp_rayritz_approx3_eq2} e \eqref{eq:exemp_rayritz_approx3_eq3}:
	
	\begin{equation}
		\label{eqn:cap_metodo_ray_ritz:sistema}
		\begin{cases}
			2a_2 + 3a_3l + 4a_4l^2 = -\dfrac{ql^2}{12EI}\\[10pt]
			a_2 + 2a_3 l + 3a_4 l^2 = - \dfrac{ql^2}{24EI}\\[10pt]
			8a_2 + 18a_3 l + \frac{144}{5} a_4 l^2 = -\dfrac{3ql^2}{10EI}
		\end{cases}
	\end{equation}
	
	Chamando $C=-\dfrac{ql^2}{12EI}$ e $D=-\dfrac{3ql^2}{10EI}$, tem-se a matriz aumentada do sistema linear \eqref{eqn:cap_metodo_ray_ritz:sistema}.
	\begin{equation}
		\label{eqn:cap_metodo_ray_ritz:matriz_sistema}
		\begin{amatrix}{3}
			2	& 	3l	&	4l^2 				& C \\
			1	& 	2l	&	3l^2			 	& \frac{1}{2}C \\
			8 	& 	18l & 	\frac{144}{5} l^2	& D
		\end{amatrix}
		\text{,}
	\end{equation}
	donde, resolvendo o sistema (Veja a Seção \ref{sec:python_solve_linsys} do Apêndice \ref{apend:python}), obtem-se os valores
	\begin{equation}
		\label{eqn:cap_metodo_ray_ritz_coef_v3_a2}
		a_2=0\text{,}
	\end{equation}
	\begin{equation}
		\label{eqn:cap_metodo_ray_ritz_coef_v3_a3}
		a_3=-\frac{ql}{12EI}\text{,}
	\end{equation}
	\begin{equation}
		\label{eqn:cap_metodo_ray_ritz_coef_v3_a4}
		a_4=\frac{q}{24EI}\text{.}
	\end{equation}
		
	Deste modo, substituindo \eqref{eqn:cap_metodo_ray_ritz_coef_v3_a2}, \eqref{eqn:cap_metodo_ray_ritz_coef_v3_a3} e \eqref{eqn:cap_metodo_ray_ritz_coef_v3_a4} em \eqref{eqn:cap_metodo_ray_ritz:func_def_v3}, a função $v_3(x)$ é escrita como
	\begin{equation}
		\label{eqn:cap_metodo_ray_ritz:func_v3}
		v_3(x) =
		\frac{q}{24EI} ( x^4 - l^3 x )
		-
		\frac{ql}{24EI} ( x^3 - l^2 x )
		\text{.}
	\end{equation}
	
	Utilizando os três valores, \eqref{eqn:cap_metodo_ray_ritz_coef_v3_a2}, \eqref{eqn:cap_metodo_ray_ritz_coef_v3_a3} e \eqref{eqn:cap_metodo_ray_ritz_coef_v3_a4}, da solução do sistema linear com matriz aumentada \eqref{eqn:cap_metodo_ray_ritz:matriz_sistema}, é possível determinar o coeficiente $a_1=-a_2l-a_3l^2-a_4l^3$, que é
	\begin{equation}
		\label{eqn:cap_metodo_ray_ritz_coef_v3_a1}
		a_1 = \frac{ql^3}{24EI}
		\text{.}
	\end{equation}	
	
	Não há, de fato, necessidade para a obtenção do valor do coeficiente $a_1$, pois $v_3(x)$ foi escrita de forma independente de $a_1$ em \eqref{eqn:cap_metodo_ray_ritz:func_def_v3}. Este apenas foi feito para que a função $v_3(x)$ possa ser escrita, a partir de \eqref{eqn:cap_metodo_ray_ritz_funcdef_v3}, como
	\begin{equation}
		\label{eqn:cap_metodo_ray_ritz:func_v3_forma2}
		v_3(x)=
			\frac{ql^3}{24EI} x
			-
			\frac{ql}{12EI} x^3
			+
			\frac{q}{24EI} x^4
		\text{.}
	\end{equation}


	O valor de máxima deflexão, $v_3(\frac{l}{2})$ é dado por
	$$
		v_3(\frac{l}{2})=\frac{5ql^4}{384EI}
		\text{,}
	$$
	que é o valor exato de $v(\frac{l}{2})$ indicado em \eqref{eqn:cap_metodo_ray_ritz:ex1_max_deflex_exato}. Não apenas isto, mas a função $v_3(x)$, indicada em \eqref{eqn:cap_metodo_ray_ritz:func_v3} ou em \eqref{eqn:cap_metodo_ray_ritz:func_v3_forma2}, é a função $v(x)$ exata.
	
	%O resultado encontrado, $v_3(x)$, é a função exata que torna o funcional \eqref{eqn:cap_metodo_ray_ritz:exemplo_func_pi} estacionário.
	
	%Encontrar a função $y(x)$ exata, analiticamente, utilizando funções aproximadoras é possível apenas quando se conhece o formato da função exata. Por exemplo, o funcional \eqref{eqn:cap_metodo_ray_ritz:exemplo_func_pi} tem sua equação de Euler-Lagrange associada com resolução analítica, facilitando, assim, o conhecimento do formato da função aproximada.}
\end{solution}

A função $v_3(x)$, apresentada em \eqref{eqn:cap_metodo_ray_ritz:func_v3}, no Exemplo \ref{ex:mrr_ex_livro}, é a função exata procurada. A escolha correta das funções de forma para a construção da função aproximadora é de suma importância para um bom resultado no método de Rayleigh-Ritz. Existem alguns critérios de convergência, que não serão tratados aqui devido sua complexidade, porém, ainda com os critérios de convergência a escolha das funções aproximadoras é uma tarefa que envolve tentativas e erros até que o resultado seja satisfatório. 

Por exemplo, o funcional \eqref{eqn:cap_metodo_ray_ritz:exemplo_func_pi} do Exemplo \ref{ex:mrr_ex_livro} tem sua função $v(x)$ exata conhecida, do Exemplo \ref{ex:cond_contorno}, facilitando, desta forma, a escolha das funções de forma. Como a função exata $v(x)$ é uma função polinomial de grau 4, a escolha da função aproximadora como uma função polinomial foi bem prática.

Devido a função exata $v(x)$ ser uma função polinomial de grau 4, caso a função aproximadora escolhida, no Exemplo \ref{ex:mrr_ex_livro}, não fosse uma função polinomial de grau 4 ou superior, dificilmente a mesma se tornaria a função exata no \index[remissivo]{Método de Rayleigh-Ritz}método de Rayleigh-Ritz.

%{\color{red}Mostrar a equação de Euler-Lagrange associada a \eqref{eqn:cap_metodo_ray_ritz:exemplo_func_pi} e resolver analiticamente demonstrando a igualdade da função exata e aproximada $v_3(x)$.}

\section{O uso de funções triangulares no método de Rayleigh-Ritz}
\label{sec:mrr_triangular}

\citeonline{MRR_Deflex} apresentam o uso de funções triangulares como funções de forma, visando a discretização da função $y(x)$. Considere o funcional
\begin{equation}
	\label{eqn:cap_metodo_ray_ritz:tri_func_funcional}
	I = \int_{0}^{1} \left [ 
		p(x) \left ( 
			\frac{dy}{dx}
		\right )^2
		+ q(x)(y(x))^2 
		- 2f(x)y(x) 
	\right ] dx
	\text{,}
\end{equation}
associado ao Problema de Valor de Contorno que modela a deflexão de uma viga apoiada sobre seus extremos. A \index[remissivo]{Função Triangular}função triangular trabalhada é definida como
\begin{equation}
	\label{eqn:cap_metodo_ray_ritz:tri_func_phi}
	\phi_i (x) = 
		\begin{cases}
			0 							& \mbox{se } 0 \leqslant x \leqslant x_{i - 1}\\[5pt]
			\dfrac{x-x_{i-1}}{h_{i-1}} 	& \mbox{se } x_{i-1} < x \leqslant x_i\\[10pt]
			\dfrac{x_{i+1}-x}{h_i}		& \mbox{se } x_i < x \leqslant x_{i+1}\\[5pt]
			0							& \mbox{se } x_{i+1}<x\leqslant 1
		\end{cases}
	\text{,}
\end{equation}
onde $h_i = x_{i+1}-x_{i}$ e $h_{i-1}=x_i-x_{i-1}$. A Figura \ref{fig:triangular_func} apresenta uma ilustração da função $\phi_i(x)$ definida. A função exata, $y(x)$, que torna um funcional estacionário, é aproximado, então, por meio da função aproximadora
\begin{equation}
	\label{eqn:cap_metodo_ray_ritz:tri_func_app_v}
	v(x)=\sum_{i=1}^{n} a_i \phi_i(x)
	\text{.}
\end{equation}

\begin{figure}[h]
	\caption{Função triangular $\phi_i(x)$.}
	\centering
	\begin{tikzpicture}
		\tkzInit[xmin=-0, xmax=10, ymin=0, ymax=6.4]
		% desenhar os eixos sem marcação
		\tkzDrawX[label={$x$}, noticks]
		\tkzDrawY[label={$y(x)=\phi_i(x)$}, noticks]
		
		% pontos da caixa
		\tkzDefPoints{
			0/0/C_1,
			10/0/C_2,
			10/6/C_3,
			0/6/C_4}
		% desenho da caixa
		%\tkzDrawSegment[color=black, line width=0.5mm, loosely dashed](C_1, C_2)
		\tkzDrawSegment[color=black, line width=0.5mm, loosely dashed](C_2, C_3)
		\tkzDrawSegment[color=black, line width=0.5mm, loosely dashed](C_3, C_4)
		%\tkzDrawSegment[color=black, line width=0.5mm, loosely dashed](C_4, C_1)
		
		% pontos da função
		\tkzDefPoints{
			0/0/F_0,
			4/0/F_1,
			6/6/F_2,
			7/0/F_3,
			10/0/F_4}
		% desenho da função
		\tkzDrawSegment[color=black, line width=0.7mm](F_0, F_1)	
		\tkzDrawSegment[color=black, line width=0.7mm](F_1, F_2)
		\tkzDrawSegment[color=black, line width=0.7mm](F_2, F_3)
		\tkzDrawSegment[color=black, line width=0.7mm](F_3, F_4)
		
		% textos das marcas: x_{i-1}, x_i, x_{i+1}
		\node at (4, -0.5) {$x_{i-1}$};
		\node at (6, -0.5) {$x_{i}$};
		\node at (7, -0.5) {$x_{i+1}$};
		
		% linha (pontilhada) em x_i
		\tkzDefPoints{
			6/0/PT_1,
			6/6/PT_2}
		\tkzDrawSegment[color=black, line width=0.5mm, dashed](PT_1, PT_2)
		
		% nome da função $\phi_i(x)$
		\node at (4, 3) {$\phi_i(x)$};
		
		% marcador dos intervalos $h_{i-1}$, $h_i$
		\node at (5, -1.2) {$h_{i-1}$};
		\tkzDefPoints{
			4/-0.8/M_1,
			4/-0.7/M_11,
			4/-0.9/M_12,
			6/-0.8/M_2,
			6/-0.7/M_21,
			6/-0.9/M_22,
			7/-0.8/M_3,
			7/-0.7/M_31,
			7/-0.9/M_32}
		\tkzDrawSegment[color=black, line width=0.5mm](M_1, M_2)
		\tkzDrawSegment[color=black, line width=0.5mm](M_11, M_12)
		\tkzDrawSegment[color=black, line width=0.5mm](M_21, M_22)
		\tkzDrawSegment[color=black, line width=0.5mm](M_2, M_3)
		\tkzDrawSegment[color=black, line width=0.5mm](M_31, M_32)
		\node at (6.5, -1.2) {$h_i$};
		\node at (-0.2, 6) {$1$};
	\end{tikzpicture}
	\label{fig:triangular_func}
	\legend{\ABNTEXfontereduzida Fonte: Elaborada pelo autor, 2019.}
\end{figure}

Observe que, de acordo com a definição das funções de forma $\phi_i(x)$, a função $v(x)$, definida como combinação linear das $\phi_i(x)$, funcionará apenas para funcionais que dependem apenas de derivadas de primeira ordem, visto que a derivada de segunda ordem de qualquer $\phi_i(x)$ é nula.

A primeira derivada das funções $\phi_i(x)$ em relação a $x$ é escrita como
\begin{equation}
	\label{eqn:cap_metodo_ray_ritz:tri_func_phi_diff}
	\phi_i ' (x) = 
		\begin{cases}
			0 							& \mbox{se } 0 \leqslant x < x_{i - 1}\\[5pt]
			\dfrac{1}{h_{i-1}} 			& \mbox{se } x_{i-1} < x < x_i\\[10pt]
			\dfrac{-1}{h_i}				& \mbox{se } x_i < x < x_{i+1}\\[5pt]
			0							& \mbox{se } x_{i+1}<x\leqslant 1
		\end{cases}
	\text{,}
\end{equation}
de onde a derivada de $v(x)$ em relação a $x$ é
\begin{equation}
	v'(x)=\sum_{i=1}^{n} a_i \phi_i '(x)
	\text{.}
\end{equation}

Aproximando $y(x)$ por meio da função $v(x)$ definida em \eqref{eqn:cap_metodo_ray_ritz:tri_func_app_v}, o funcional \eqref{eqn:cap_metodo_ray_ritz:tri_func_funcional} é escrito como
\begin{equation}
	\label{eqn:cap_metodo_ray_ritz:tri_func_funcional_approx}
	I = \int_{0}^{1} \left [
		p(x) \left (
			\sum_{i=1}^{n} a_i \phi_i '(x)
		\right )^2
		+ q(x) \left (
			\sum_{i=1}^{n} a_i \phi_i (x)
		\right )^2
		- 2f(x) \left (
			\sum_{i=1}^{n} a_i \phi_i (x)
		\right )
	\right ] dx
	\text{.}
\end{equation}

Para determinar os coeficientes $a_j$, as derivadas parciais de \eqref{eqn:cap_metodo_ray_ritz:tri_func_funcional_approx} em relação aos $a_j$ devem ser todas nulas, ou seja,
$$
	\frac{\partial I}{\partial a_j} = 0
	\text{,}
$$
onde $j=1$, $2$, $\dots$, $n$. Utilizando A Regra de Leibniz (Teorema \ref{teorema:regra_de_leibniz} do Apêndice \ref{apend:regra_de_leibniz}),
\begin{equation}
	\label{eqn:cap_metodo_ray_ritz:tri_func_funcional_derivada}
	\frac{\partial I}{\partial a_j} = 
	\int_{0}^{1} \left [
		2p(x) \left (
			\sum_{i=1}^{n} a_i \phi_i'(x)
		\right ) \phi_j'(x)
		+ 2q(x) \left (
			\sum_{i=1}^{n} a_i \phi_i(x)
		\right ) \phi_j(x)
		- 2f(x)\phi_j(x)
	\right ] dx
	\text{.}
\end{equation}

Em \eqref{eqn:cap_metodo_ray_ritz:tri_func_funcional_derivada} foi utilizado o fato de que a derivada de $\displaystyle \sum_{i=1}^{n} a_i \phi_i(x)$ em relação a algum $a_j$, onde $1\leqslant j\leqslant n$, resulta em $\phi_j(x)$. O mesmo vale para a derivada de $\displaystyle \sum_{i=1}^{n} a_i \phi_i'(x)$ em relação a algum $a_j$, $1\leqslant j\leqslant n$, que resulta em $\phi_j'(x)$.

Aplicando a distributividade na primeira e segunda parcela do integrando em \eqref{eqn:cap_metodo_ray_ritz:tri_func_funcional_derivada}, tem-se
$$
	\frac{\partial I}{\partial a_j} = \int_0^1 \left [
		\sum_{i=1}^n \left ( 2p(x)a_i \phi_i'(x)\phi_j'(x) \right)
		+
		\sum_{i=1}^n \left ( 2q(x)a_i\phi_i(x)\phi_j(x) \right)
		- 2f(x)\phi_j(x)
	\right ] dx
$$
$$
	\frac{\partial I}{\partial a_j} = \int_0^1 \left [
		\sum_{i=1}^n \left (
			2p(x)a_i \phi_i'(x)\phi_j'(x)
			+
			2q(x)a_i\phi_i(x)\phi_j(x)
		\right )
	\right ] dx
	- \int_0^1 2f(x)\phi_j(x)dx
	\text{,}
$$
de onde, alterando a ordem de integração e soma, resulta em
\begin{equation}
	\label{eqn:cap_metodo_ray_ritz:tri_func_aj_evidence}
	\frac{\partial I}{\partial a_j} = \sum_{i=1}^n \left (
		\int_0^1 \left [
			2p(x)a_i\phi_i'(x)\phi_j'(x)
			+
			2q(x)a_i\phi_i(x)\phi_j(x)
		\right ] dx
	\right )
	- \int_0^1 2f(x)\phi_j(x)dx
	\text{.}
\end{equation}

%Manipulando as ordens de integração e de soma em \eqref{eqn:cap_metodo_ray_ritz:tri_func_funcional_derivada} tem-se
De \eqref{eqn:cap_metodo_ray_ritz:tri_func_aj_evidence}, como $a_i$ é constante na integração em relação a $x$, tem-se
$$
	\frac{\partial I}{\partial a_j} = \sum_{i=1}^{n} \left (
		a_i \int_{0}^{1} \left [
			2p(x)\phi_i'(x)\phi_j'(x)
			+
			2q(x)\phi_i(x)\phi_j(x)
		\right ]
	\right )
	-
	\int_{0}^{1} 2f(x)\phi_j(x)dx
	\text{,}
$$
que, aplicando a condição $\dfrac{\partial I}{\partial a_j}=0$, obtêm-se
$$
	\sum_{i=1}^{n} \left (
		a_i \int_{0}^{1} \left [
			2p(x)\phi_i'(x)\phi_j'(x)
			+
			2q(x)\phi_i(x)\phi_j(x)
		\right ]
	\right )
	-
	\int_{0}^{1} 2f(x)\phi_j(x)dx
	= 0
	\text{,}
$$
resultando em um sistema de $n$ equações com $n$ incógnitas da forma
\begin{equation}
	\label{eqn:cap_metodo_ray_ritz:tri_func_sistema}
	\sum_{i=1}^{n} \left (
		a_i \int_{0}^{1} \left [
			2p(x)\phi_i'(x)\phi_j'(x)
			+
			2q(x)\phi_i(x)\phi_j(x)
		\right ] dx
	\right )
	=
	\int_{0}^{1} 2f(x)\phi_j(x)dx
	\text{,}
\end{equation}
onde $j=1$, $2$, $\dots$, $n$.

Chamando
\begin{equation}
	\label{eqn:cap_metodo_ray_ritz:tri_func_mji}
	m_{j,i}=\int_{0}^{1} \left [
		2p(x)\phi_i'(x)\phi_j'(x)
		+
		2q(x)\phi_i(x)\phi_j(x)
	\right ]dx
	\text{,}
\end{equation}
e
\begin{equation}
	\label{eqn:cap_metodo_ray_ritz:tri_func_bj}
	b_j=\int_{0}^{1} 2f(x)\phi_j(x)dx
	\text{,}
\end{equation}
o sistema \eqref{eqn:cap_metodo_ray_ritz:tri_func_sistema} pode ser escrito na forma 
\begin{equation}
	\label{eqn:cap_metodo_ray_ritz:tri_func_sistema_generic}
	\displaystyle\sum_{i=1}^n a_i\cdot m_{j,i}=b_j
	\text{,}
\end{equation}
onde $j=1,2,\dots,n$. Seja as matrizes $M=[m_{j,i}]$ de ordem $n\times n$, $B=[b_j]$ de ordem $n\times 1$ e $A=[a_j]$ de ordem $n\times 1$, então o sistema \eqref{eqn:cap_metodo_ray_ritz:tri_func_sistema_generic} é escrito como $M\cdot A=B$. A matriz $M$ é a matriz de coeficientes, a matriz $A$ é a matriz coluna de incógnitas e $B$ é a matriz coluna contendo os termos independentes.

%O sistema \eqref{eqn:cap_metodo_ray_ritz:tri_func_sistema} pode ser escrito na forma matricial $M\cdot A=B$, onde $M=[m_{j, i}]$ é a matriz de coeficientes, $A=[a_i]$ é a matriz coluna de incógnitas e $B=[b_j]$ é a matriz contendo os termos independentes. Assim, de \eqref{eqn:cap_metodo_ray_ritz:tri_func_sistema},
%\begin{equation}
%	\label{eqn:cap_metodo_ray_ritz:tri_func_mji}
%	m_{j,i}=\int_{0}^{1} \left [
%		2p(x)\phi_i'(x)\phi_j'(x)
%		+
%		2q(x)\phi_i(x)\phi_j(x)
%	\right ]dx
%	\text{,}
%\end{equation}
%\begin{equation}
%	\label{eqn:cap_metodo_ray_ritz:tri_func_bj}
%	b_j=\int_{0}^{1} 2f(x)\phi_j(x)dx
%	\text{.}
%\end{equation}

A partir de \eqref{eqn:cap_metodo_ray_ritz:tri_func_phi} e \eqref{eqn:cap_metodo_ray_ritz:tri_func_phi_diff}, os produtos $\phi_i(x)\phi_j(x)$ e $\phi_i'(x)\phi_j'(x)$ são não nulos apenas quando $i=j-1$, $i=j$ e $i=j+1$. Consequentemente, $m_{j,i}$ é não nulo apenas para $i=j-1$, $i=j$ e $i=j+1$.

A construção do sistema $M\cdot A=B$ e sua resolução, pelo \index[remissivo]{Método de Gauss-Jordan}método de Gauss-Jordan, serão implementado na linguagem de programação \textit{Python} na Seção \ref{sec:python_triangular} do Capítulo \ref{cap:python}.

\chapter{UTILIZANDO O MÉTODO DE RAYLEIGH-RITZ NA LINGUAGEM \textit{PYTHON}}
\label{cap:python}

Em se tratando de programação, existem diversas formas de se trabalhar o \index[remissivo]{Método de Rayleigh-Ritz}método de Rayleigh-Ritz em diversas linguagens. Para este trabalho foi escolhida a linguagem \index[remissivo]{Python}\textit{Python} por ser uma liguagem gratuita, de código aberto, e com forte apelo a computação científica. Ainda assim, existem diversas formas de se implementar algoritmos para o uso deste método. O objetivo deste capítulo é de trabalhar e exemplificar como o método pode ser implementado utilizando a linguagem de programação \textit{Python}.

Voltando ao funcional $\Pi$, definido em \eqref{eqn:cap_metodo_ray_ritz:exemplo_func_pi} no Exemplo \ref{ex:mrr_ex_livro} do Capítulo \ref{cap:mrr}, tem-se
$$
	\Pi = 
		\frac{1}{2} \int_0^l EI \left [
			\frac{d^2v}{dx^2}
		\right ]^2 dx
		-
		\int_0^l qvdx
$$
e tomando, ainda, a função aproximadora $v_3(x)=a_0+a_1 x + a_2 x^2 + a_3 x^3 + a_4 x^4$, donde aplicando as condições de contorno essenciais, $v_3(0)=0$, obtendo $a_0=0$, e $v_3(l)=0$, encontrando $a_1=-a_2l-a_3l^2-a_4l^3$. Substituindo $a_0$ e $a_1$ em $v_3(x)$, tem-se a função
$$
	v_3(x)=
	a_2 (x^2 - lx)
	+
	a_3 (x^3 - l^2x)
	+
	a_4 (x^4 - l^3x)
	\text{.}
$$

Derivando $v_3$ em relação a $x$ duas vezes,
$$
	v_3''(x)=
	2a_2
	+
	6a_3 x
	+
	12a_4 x^2
	\text{.}
$$
	
Para a determinação dos parâmetros $a_2$, $a_3$ e $a_4$, deve-se substituir $v_3(x)$ no funcional $\Pi$, e resolver o sistema 
$$
	\begin{cases}
		\dfrac{\partial \Pi}{\partial a_2}=0\\[10pt]
		\dfrac{\partial \Pi}{\partial a_3}=0\\[10pt]
		\dfrac{\partial \Pi}{\partial a_4}=0
	\end{cases}
	\text{.}
$$

Tanto a derivação quanto a integração podem ser feitas manualmente ou utilizando o pacote \textit{SymPy} em \textit{Python}, como feito no Código \ref{py_code_solve_mrr_ex_livro_diff}.

\newpage
\begin{lstlisting}[style=Python, xleftmargin=2em, numbers=left, caption={Código para a resolução do Exemplo \ref{ex:mrr_ex_livro}}, captionpos=t, label=py_code_solve_mrr_ex_livro_diff]
from sympy import symbols, integrate, diff, Matrix
from sympy.solvers import solve

l, E, I, x, q = symbols('l E I x q')
a2, a3, a4 = symbols("a2 a3 a4")

v = a2 * (x**2 - l*x) 
v = v + a3 * (x**3 - l**2 * x)
v = v + a4 * (x**4 - l**3 * x)

dv = diff(v, x)
dv2 = diff(dv, x)

f = (E*I*((dv2)**2)) / 2 - q * v

df_a2 = diff(f, a2)
df_a3 = diff(f, a3)
df_a4 = diff(f, a4)

eq1 = integrate(df_a2, (x, 0, l))
eq2 = integrate(df_a3, (x, 0, l))
eq3 = integrate(df_a4, (x, 0, l))

sol = solve([eq1, eq2, eq3], [a2, a3, a4])
print(sol)
\end{lstlisting}
\codigofonte

O Código \ref{py_code_solve_mrr_ex_livro_diff} é executado rapidamente e o resultado é mostrado na Figura \ref{fig:code_solve_mrr_exemplo_livro}, com $a_2=0$, $a_3=-\dfrac{ql}{12EI}$ e $a_4=\dfrac{q}{24EI}$. Esses resultados são exatamente os mesmos apresentados no Exemplo \ref{ex:mrr_ex_livro}.

\begin{figure}[h]
	\caption{Resultado apresentado pelo Código \ref{py_code_solve_mrr_ex_livro_diff}.}
	\centering
	\includegraphics[scale=2.5]{../figuras/code/code_solve_mrr_exemplo_livro.png}
	\label{fig:code_solve_mrr_exemplo_livro}
	\legend{\ABNTEXfontereduzida Fonte: Elaborada pelo autor, 2019.}
\end{figure}

O valor de $a_1=-a_2l-a_3l^2-a_4l^3$ é determinado substituindo os valores de $a_2$, $a_3$ e $a_4$. Esse processo pode ser realizado de modo manual ou, mais rapidamente, utilizando a própria linguagem, adicionando o Código \ref{py_code_solve_mrr_isolatedcoef_ex_livro} ao final do Código \ref{py_code_solve_mrr_ex_livro_diff}. Os comandos \textit{a1 = a1.subs(a2, sol[a2])} indica que a variável \textit{a1} receberá o valor de \textit{a1} substituindo o simbólo \textit{a2} pela solução do sistema encontrada no Código \ref{py_code_solve_mrr_ex_livro_diff}.
\newpage

\begin{lstlisting}[style=Python, xleftmargin=2em, numbers=left, firstnumber=26, caption={Código para a determinação do coeficiente $a_1$ do Exemplo \ref{ex:mrr_ex_livro}}, captionpos=t, label=py_code_solve_mrr_isolatedcoef_ex_livro]
a1 = -a2*l - a3*l**2 - a4 * l**3
a1 = a1.subs(a2, sol[a2])
a1 = a1.subs(a3, sol[a3])
a1 = a1.subs(a4, sol[a4])
print(a1)
\end{lstlisting}
\codigofonte

É possível, ainda, construir uma função $v(x)$ utilizando os coeficientes $a_1$, $a_2$, $a_3$ e $a_4$ (O coeficiente $a_0$ foi ignorado devido ao seu valor ser nulo) com o Código \ref{py_code_solve_mrr_maxdef_ex_livro}. Utilizando, novamente, o comando \textit{subs} e a função definida no Código \ref{py_code_solve_mrr_maxdef_ex_livro}, pode-se calcular o valor de $v_3(x)$ em algum ponto, como, por exemplo, em $x=\dfrac{l}{2}$. O valor $v_3(\frac{l}{2})$ é o valor de máxima deflexão.

\begin{lstlisting}[style=Python, xleftmargin=2em, numbers=left, firstnumber=31, caption={Código para a definição da função $v_3(x)$ do Exemplo \ref{ex:mrr_ex_livro}}, captionpos=t, label=py_code_solve_mrr_maxdef_ex_livro]
v = a1*x + sol[a2]*x**2 + sol[a3]*x**3 + sol[a4]*x**4
print(v)
maxdef = v.subs(x, l/2)
print(maxdef)
\end{lstlisting}
\codigofonte

É importante observar, no Código \ref{py_code_solve_mrr_maxdef_ex_livro}, que ao construir a variável \textit{v} para representar a função, no primeiro coeficiente foi utilizado a variável \textit{a1}, enquanto que nas demais, foi utilizado \textit{sol[a2]}, \textit{sol[a3]} e \textit{sol[a4]}. Isso se deve ao fato de que os valores para os coeficientes $a_2$, $a_3$ e $a_4$ foram encontrados pela resolução do sistema, sendo a variável \textit{sol} a sua solução. Já, \textit{a1} foi definida como sendo a equação do termo $a_1$ isolado em função de $a_2$, $a_3$ e $a_4$.

Os Códigos \ref{py_code_solve_mrr_ex_livro_diff}, \ref{py_code_solve_mrr_isolatedcoef_ex_livro} e \ref{py_code_solve_mrr_maxdef_ex_livro} são executados em sequência e, por essa razão, estão com numeração de linhas sequenciais: O Código \ref{py_code_solve_mrr_ex_livro_diff} tendo as linhas de 1 a 25, o Código \ref{py_code_solve_mrr_isolatedcoef_ex_livro} de 26 a 30 e o Código \ref{py_code_solve_mrr_maxdef_ex_livro} de 31 a 34. A Figura \ref{fig:code_solve_mrr_exec_complete} mostra o resultado da execução dos Códigos \ref{py_code_solve_mrr_ex_livro_diff}, \ref{py_code_solve_mrr_isolatedcoef_ex_livro} e \ref{py_code_solve_mrr_maxdef_ex_livro} no terminal.

\begin{figure}[h]
	\caption{Resultado apresentado pelos Códigos \ref{py_code_solve_mrr_ex_livro_diff}, \ref{py_code_solve_mrr_isolatedcoef_ex_livro} e \ref{py_code_solve_mrr_maxdef_ex_livro}.}
	\centering
	\includegraphics[scale=2.5]{../figuras/code/code_solve_mrr_exec_complete.png}
	\label{fig:code_solve_mrr_exec_complete}
	\legend{\ABNTEXfontereduzida Fonte: Elaborada pelo autor, 2019.}
\end{figure}

Observando, no terminal da Figura \ref{fig:code_solve_mrr_exec_complete}, pela ordem dos comandos \textit{print} executados no código, a primeira linha apresenta a solução do sistema, a segunda linha apresenta o valor do coeficiente $a_1$, a terceira linha apresenta a função $v_3(x)$ e a quarta linha apresenta o resultado de $v_3(\frac{l}{2})$ que é o valor de máxima deflexão da viga.

Ressaltando, novamente, que a escolha das funções de forma utilizadas na função aproximadora são de suma importância para o método de Rayleigh-Ritz. Para o uso de matemática simbólica, como nesse exemplo, deve-se tomar ainda mais cuidado com a escolha de tais funções pois, em alguns casos, a integração simbólica toma grande custo computacional. Em casos onde a integração simbólica se torna árdua, ou até mesmo impossível, o uso de algoritmos para integração numérica é necessário.

\section{Resolvendo problemas com o método de Rayleigh-Ritz utilizando funções triangulares em \textit{Python}}
\label{sec:python_triangular}

O sistema $M\cdot A=B$, encontrado na Seção \ref{sec:mrr_triangular} do Capítulo \ref{cap:mrr}, pode ser resolvido, numericamente, utilizando a linguagem de programação \index[remissivo]{Python}\textit{Python}. A título de comparação serão utilizadas as funções $p(x)=e^x$, $q(x)=e^x$ e $f(x)=x+(2-x)e^x$ que possui função exata $y(x)$ conhecida dada por $y(x)=(x-1)(e^{-x}-1)$.

Viabilizando a implementação do algoritmo, faz-se necessário relembrar $m_{j,i}$ e $b_j$, obtidos em \eqref{eqn:cap_metodo_ray_ritz:tri_func_mji} e \eqref{eqn:cap_metodo_ray_ritz:tri_func_bj}, respectivamente:
\begin{equation}
	\label{eqn:python_tri_func_mji}
	m_{j,i}=\int_{0}^{1} \left [
		2p(x)\phi_i'(x)\phi_j'(x)
		+
		2q(x)\phi_i(x)\phi_j(x)
	\right ]dx
	\text{,}
\end{equation}
\begin{equation}
	\label{eqn:python_tri_func_bj}
	b_j=\int_{0}^{1} 2f(x)\phi_j(x)dx
	\text{.}
\end{equation}

É útil, também, a definição da função de forma $\phi_i(x)$, feita em \eqref{eqn:cap_metodo_ray_ritz:tri_func_phi}, e sua derivada, $\phi_i'(x)$, obtida em \eqref{eqn:cap_metodo_ray_ritz:tri_func_phi_diff}:

\begin{equation}
	\label{eqn:python_tri_func_phi}
	\phi_i (x) = 
		\begin{cases}
			0 							& \mbox{se } 0 \leqslant x \leqslant x_{i - 1}\\
			\dfrac{x-x_{i-1}}{h_{i-1}} 	& \mbox{se } x_{i-1} < x \leqslant x_i\\
			\dfrac{x_{i+1}-x}{h_i}		& \mbox{se } x_i < x \leqslant x_{i+1}\\
			0							& \mbox{se } x_{i+1}<x\leqslant 1
		\end{cases}
	\text{,}
\end{equation}

\begin{equation}
	\label{eqn:python_tri_func_phi_diff}
	\phi_i ' (x) = 
		\begin{cases}
			0 							& \mbox{se } 0 \leqslant x < x_{i - 1}\\
			\dfrac{1}{h_{i-1}} 			& \mbox{se } x_{i-1} < x < x_i\\
			\dfrac{-1}{h_i}				& \mbox{se } x_i < x < x_{i+1}\\
			0							& \mbox{se } x_{i+1}<x\leqslant 1
		\end{cases}
	\text{.}
\end{equation}

Para a resolução do problema, o primeiro passo é importar os componentes a serem utilizados. No Código \ref{py_code_solve_mrr_tri_import} são importados os componentes \textit{numpy}, utilizado para a criação de alguns intervalos numéricos espaçados. Do pacote \textit{math} é importando a constante $e$. Do pacote \textit{sympy} é importado o método \textit{symbols} para a definição de símbolos matemáticos, de \textit{sympy.matrices} é importado o método \textit{zeros} para a criação de um matriz de tamanho determinado preenchida por números zeros e de \textit{sympy.solvers} é importado o método \textit{linsolve} utilizado para a resolução de sistemas lineares. Por último, é importado o pacote \textit{matplotlib.pyplot} como \textit{pyplot}\footnote{Utilizar o comando \textit{import matplotlib.pyplot as pyplot} faz com que, em vez de sempre escrever \textit{matplotlib.pyplot}, se possa escrever apenas \textit{pyplot} nos próximos comandos.} utilizado para plotar gráficos.

\newpage

\begin{lstlisting}[style=Python, xleftmargin=2em, numbers=left, firstnumber=1, caption={Importação dos pacotes utilizados para a resolução}, captionpos=t, label=py_code_solve_mrr_tri_import]
import numpy
from math import e
from sympy import symbols
from sympy.matrices import zeros
from sympy.solvers import linsolve
import matplotlib.pyplot as pyplot
import matplotlib.patches as patches
\end{lstlisting}
\codigofonte

Para o uso das funções de forma $\phi_i(x)$ e $\phi_i'(x)$, definidas em \eqref{eqn:python_tri_func_phi} e \eqref{eqn:python_tri_func_phi_diff}, respectivamente, é preciso criar um conjunto numérico espaçado (aqui o conjunto será igualmente espaçado, mas nada impede o uso de conjuntos com espaçamentos diferentes). Para a criação desse conjunto foi utilizada a função \textit{numpy.arange}\footnote{A função \textit{numpy.arange} cria valores espaçados uniformemente dentro de um determinado intervalo.}, em Código \ref{py_code_solve_mrr_tri_interval}. No comando \textit{arange}. O uso do extremo $1.0001$ é apenas para garantir que o número $1$ esteja no conjunto gerado. A variável \textit{n} representa a quantidade de divisões a serem utilizadas no intervalo para a discretização da função exata.

\begin{lstlisting}[style=Python, xleftmargin=2em, numbers=left, firstnumber=8, caption={Criação dos intervalos numéricos}, captionpos=t, label=py_code_solve_mrr_tri_interval]
n = 5
space = 1/(n + 1)
intervals = numpy.arange(0, 1.0001, space)
\end{lstlisting}
\codigofonte

\begin{lstlisting}[style=Python, xleftmargin=2em, numbers=left, firstnumber=11, caption={Função de forma $\phi$ e sua derivada}, captionpos=t, label=py_code_solve_mrr_tri_form_func]
def fi(i, x):
    if x <= intervals[i - 1]:
        return 0
    elif x <= intervals[i]:
        h = (intervals[i] - intervals[i - 1])
        return ((x - intervals[i - 1]) / h)
    elif x <= intervals[i + 1]:
        h = (intervals[i + 1] - intervals[i])
        return ((intervals[i + 1] - x) / h)
    else:
        return 0

def fi_diff(i, x):
    if x <= intervals[i - 1]:
        return 0
    elif x <= intervals[i]:
        return (1 / (intervals[i] - intervals[i - 1]))
    elif x <= intervals[i + 1]:
        return (1 / (intervals[i] - intervals[i + 1]))
    else:
        return 0
\end{lstlisting}
\codigofonte

Numericamente, as funções $\phi_i(x)$ e $\phi_i'(x)$ foram programadas utilizando condicionais, em Código \ref{py_code_solve_mrr_tri_form_func}.

No Código \ref{py_code_solve_mrr_tri_form_func} o método utilizado para a integração numérica, que implementa a chamada regra do trapézio, é mostrado. Dentro do método, a variável \textit{steps} define em quantos intervalos o domínio de integração será dividido. Os parâmetros opcionais \textit{*args}, do método \textit{integrate}, são passados para a função a ser integrada, \textit{func}, e serão utilizados para passar os índices $i$ e $j$ quando necessário.

\begin{lstlisting}[style=Python, xleftmargin=2em, numbers=left, firstnumber=32, caption={Algoritmo para integração numérica usando a regra dos trapézios}, captionpos=t, label=py_code_solve_mrr_tri_integrate]
def integrate(func, start, end, *args):
    steps = 10000
    h = ((end - start) / steps)
    half = h / 2
    value = 0
    for i in range(0, steps):
        dh = func(start + h * i + half, *args)
        if i == 0 or i == (steps - 1):
            value += dh
        else:
            value += (2 * dh)
    return (value * (h / 2))
\end{lstlisting}
\codigofonte

Para a integração numérica por meio do algoritmo implementado em Código \ref{py_code_solve_mrr_tri_integrate} é preciso definir funções com os integrandos de \eqref{eqn:python_tri_func_mji} e \eqref{eqn:python_tri_func_bj}. Essas funções são chamadas, no código, de \textit{m\underline{\hspace{.1in}}intern} e \textit{b\underline{\hspace{0.1in}}intern}, respectivamente. Na implementação do Código \ref{py_code_solve_mrr_tri_m_b}, os métodos \textit{m(i, j)} e \textit{b(i)} calculam os elementos das matrizes $M$ e $B$, respectivamente. Nesses métodos, é somado 1 aos índices $i$ e $j$ pois, na programação os elementos são indexados a partir de 0 e, na forma como definimos as funções de forma $\phi_i(x)$, elas são indexadas a partir de 1.

\begin{lstlisting}[style=Python, xleftmargin=2em, numbers=left, firstnumber=44, caption={Funções utilizadas para criação das matrizes do sistema linear}, captionpos=t, label=py_code_solve_mrr_tri_m_b]
def p(x):
    return e**x

def q(x):
    return e**x

def f(x):
    return (x+(2-x)*e**x)

def m_intern(x, i, j):
    value = p(x) * fi_diff(i, x) * fi_diff(j, x)
    value = value + q(x) * fi(i, x) * fi(j, x)
    return value

def m(i, j):
    i = i + 1
    j = j + 1
    return integrate(m_intern, 0, 1, i, j)

def b_intern(x, i):
    return (f(x) * fi(i, x))

def b(i):
    i = i + 1
    return integrate(b_intern, 0, 1, i)
\end{lstlisting}
\codigofonte

O próximo passo, consiste em criar a matriz aumentada do sistema, os símbolos que representam as incógnitas e, então, resolvê-lo. Isso é feito no Código \ref{py_code_solve_mrr_tri_solvesys}.


\begin{lstlisting}[style=Python, xleftmargin=2em, numbers=left, firstnumber=69, caption={Definição e resolução do sistema linear}, captionpos=t, label=py_code_solve_mrr_tri_solvesys]
M = zeros(n, n+1)
for i in range(0, n):
    M[i, n] = b(i)
    M[i, i] = m(i, i)
    if (i - 1) >= 0:
        M[i, i - 1] = m(i, i - 1)
    if (i + 1) < n:
        M[i, i + 1] = m(i, i + 1)
coeficients = symbols('a_0:{}'.format(n))
solution, = linsolve(M, coeficients)
\end{lstlisting}
\codigofonte

Utilizando a solução do Código \ref{py_code_solve_mrr_tri_solvesys} e a função exata $y(x)=(x-1)(e^{-x}-1)$, é possível implementar métodos que representam a função exata e a função aproximada, plotando-as no mesmo gráfico, como feito no Código \ref{py_code_solve_mrr_tri_plot}.

\begin{lstlisting}[style=Python, xleftmargin=2em, numbers=left, firstnumber=79, caption={Plotagem das funções exata e aproximada}, captionpos=t, label=py_code_solve_mrr_tri_plot]
def function(solution, x):
    value = 0
    i = 0
    for c in solution:
        value += c * fi(i + 1, x)
        i = i + 1
    return value
def function_original(x):
    return ((x - 1) * (e**(-x) - 1))

plot_interval = numpy.arange(0.0, 1.0, 0.01)
plot_original = function_original(plot_interval)
plot_aprox = []
for i in plot_interval:
    plot_aprox.append(function(solution, i))
fig = pyplot.figure()
axes = fig.add_subplot(1, 1, 1)
color1='tab:blue'
color2='tab:orange'
axes.plot(plot_interval, plot_aprox, color=color1)
axes.plot(plot_interval, plot_original, color=color2)
axes.set_title('Rayleigh-Ritz With n=' + str(n))
blue_legend = patches.Patch(color=color1, label='Aproximada')
orange_legend = patches.Patch(color=color2, label='Exata')
pyplot.legend(handles=[blue_legend, orange_legend])
pyplot.show()
\end{lstlisting}
\codigofonte

Os Códigos \ref{py_code_solve_mrr_tri_import}, \ref{py_code_solve_mrr_tri_interval}, \ref{py_code_solve_mrr_tri_form_func}, \ref{py_code_solve_mrr_tri_integrate}, \ref{py_code_solve_mrr_tri_m_b}, \ref{py_code_solve_mrr_tri_solvesys} e \ref{py_code_solve_mrr_tri_plot} são sequênciais e devem ser executados dentro de um único arquivo, por isso suas numerações estão sequênciais. O resultado da execução do código para a resolução do sistema é mostrado na Figura \ref{fig:code_plot_mrr_triangulate}, onde a curva de cor laranja é a solução exata e a curva de cor azul é a discretização. Para maior precisão do método, pode-se aumentar o valor da variável \textit{n} do Código \ref{py_code_solve_mrr_tri_interval}, por exemplo, para 10. O gráfico plotado para $n=10$ é apresentado na Figura \ref{fig:code_plot_mrr_triangulate_n10}.

Quanto maior o valor da variável \textit{n} no Código \ref{py_code_solve_mrr_tri_interval} maior a precisão, porém, com maior custo computacional. Consequentemente, quanto maior o valor de \textit{n}, mais tempo o computador levará para a resolução do problema.

\begin{figure}[h]
	\caption{Resultado do método de Rayleigh-Ritz utilizando funções de forma triangulares com $n=5$.}
	\centering
	\includegraphics[scale=0.65]{../figuras/code/code_plot_mrr_triangulate.png}
	\label{fig:code_plot_mrr_triangulate}
	\legend{\ABNTEXfontereduzida Fonte: Elaborada pelo autor, 2019.}
\end{figure}

\begin{figure}[h]
	\caption{Resultado do método de Rayleigh-Ritz utilizando funções de forma triangulares com $n=10$.}
	\centering
	\includegraphics[scale=0.65]{../figuras/code/code_plot_mrr_triangulate_n10.png}
	\label{fig:code_plot_mrr_triangulate_n10}
	\legend{\ABNTEXfontereduzida Fonte: Elaborada pelo autor, 2019.}
\end{figure}

% ---
% Considerações Finais
% ---
\chapter*{CONSIDERAÇÕES FINAIS}
\addcontentsline{toc}{chapter}{CONSIDERAÇÕES FINAIS}
% ---

Nesse trabalho, o cálculo variacional e o método de Rayleigh-Ritz foram expostos de forma introdutória, inclusive, desenvolvendo as demonstrações e cálculos, de modo que todo aluno com conhecimentos de cálculo em várias variáveis possa compreender as ideias trabalhadas. No decorrer dos estudos sobre tais temas foi observado a importância e a necessidade de materiais introdutórios sobre ambos os temas.

Para o cálculo variacional, o enfoque foi dado nas equações de Euler-Lagrange, condição necessária para a estacionariedade de um funcional, de funcionais que dependem de uma váriavel, uma função e de suas derivadas até uma ordem $n$ qualquer. Esse enfoque dado se deve, primeiramente, ao enfoque introdutório do trabalho e, em segundo lugar, a grande gama de aplicações que podem ser desenvolvidas com as ferramentas estudadas, por exemplo, ao se provar que a curva de menor comprimento entre dois pontos é um segmento de reta.

Já no método de Rayleigh-Ritz, o foco foi dividido entre uma introdução ao tema, desenvolvendo todos os cálculos referentes ao exemplo, e o uso da Linguagem de Programação \textit{Python} para agilizar o processo de minimização dos funcionais de forma rápida e simples, realizando as derivações, integrações e, ainda, resolvendo sistemas de equações.

Os estudos desenvolvidos com a linguagem \textit{Python} mostraram, também, a utilidade da linguagem no meio científico, realizando tanto operações numéricas quanto manipulações simbólicas de forma eficiente. Isso evidencia a importância da linguagem por ser gratuita, de código aberto e multiplataforma, ou seja, uma linguagem acessível.

O estudo introdutório ao cálculo variacional e ao método de Rayleigh-Ritz, aqui apresentado, pode ser ampliado, por exemplo, para funções de mais variáveis, problemas de fronteira livres onde as condições de contorno são de outra forma, indo, até mesmo, aos métodos modernos que utilizam, por exemplo, inteligência artificial, como o método \textit{Deep Ritz} citado no primeiro capítulo desse trabalho.

% ----------------------------------------------------------
% ELEMENTOS PÓS-TEXTUAIS
% ----------------------------------------------------------
\postextual
% ----------------------------------------------------------

% ----------------------------------------------------------
% Referências bibliográficas
% ----------------------------------------------------------
\bibliography{../references}

% ----------------------------------------------------------
% Glossário
% ----------------------------------------------------------
%
% Consulte o manual da classe abntex2 para orientações sobre o glossário.
%
%\glossary

% ----------------------------------------------------------
% Apêndices
% ----------------------------------------------------------

% ---
% Inicia os apêndices
% ---
\begin{apendicesenv}

% Imprime uma página indicando o início dos apêndices
\partapendices

% Apêndice A
\chapter{CONCEITOS DE ANÁLISE NO $\mathbb{R}^n$}
\label{apend:regra_de_leibniz}
{
	Durante o desenvolvimento dos resultados do texto, tais como a obtenção da equação de Euler-Lagrange, é necessário o uso de alguns conceitos e resultados de Análise no $\mathbb{R}^n$. Estes conceitos serão trabalhados neste apêndice, tomando como referência \citeonline{analise_elon2}.

	\begin{definicao}
		Um conjunto $K\subset \mathbb{R}^n$ é \index[remissivo]{Conjunto Compacto}compacto se, e somente se, toda sequência de pontos em $K$ possui uma subsequência que converge para um ponto de $K$.
	\end{definicao}

	\begin{teorema}
		\label{teorema:func_uniformemente}
		Seja $f:X\times K \longrightarrow \mathbb{R}^n$ contínua, onde $X\subset \mathbb{R}^m$, para algum $m$, e $K$ é compacto. Fixemos $x_0 \in X$. Para todo $\varepsilon > 0$, existe um $\delta > 0$ tal que $x\in X$, $|x-x_0|<\delta \Longrightarrow |f(x, \alpha)-f(x_0,\alpha)|<\varepsilon$, seja qual for $\alpha \in K$.
		\begin{proof}
		Suponha que o teorema não seja válido, então existiriam $\varepsilon > 0$ e sequências de pontos $x_k\in X$, $\alpha_k \in K$ tais que $|x_k-x_0|<\frac{1}{k}$ e $|f(x_k,\alpha_k)-f(x_0,\alpha_k)|\geqslant \varepsilon$. Passando a uma subsequência, se necessário e admitindo que $\lim \alpha_k=\alpha \in K$, devido ao fato de que o conjunto $K$ é compacto.
		
		Como, $|x_k-x_0|<\frac{1}{k}$, $-\frac{1}{k}<x_k-x_0<\frac{1}{k}$, então, $x_0-\frac{1}{k}<x_k<x_0+\frac{1}{k}$, e, como $\lim \left (x_0-\frac{1}{k} \right ) = x_0$ e $\lim \left ( x_0 + \frac{1}{k} \right )=x_0$, então, $\lim x_k=x_0$. Devido a continuidade de $f$ tem-se $\varepsilon \leqslant \lim |f(x_k,\alpha_k)-f(x_0,\alpha _k)|=|f(x_0,\alpha)-f(x_0,\alpha)|=0$, uma contradição, pois da hipótese $\varepsilon >0$.
		\end{proof}
	\end{teorema}
	
	\begin{teorema}[Derivação sob o sinal de integral ou Regra de Leibniz]
		\index[remissivo]{Regra de Leibniz}
		\index[remissivo]{Derivação Sob o Sinal de Integral}
		\label{teorema:regra_de_leibniz}
		Dado $U\subset \mathbb{R}^n$, aberto, seja $f:U\times[a,b]\longrightarrow \mathbb{R}$ uma função com as seguintes propriedades:
		\begin{enumerate}
			\item Para todo $x \in U$, a função $x \longmapsto f(x,t)$ é integrável em $a \leqslant t \leqslant b$.
			\item A $i$-ésima derivada parcial $\frac{\partial f}{\partial x_i}(x,t)$ existe para cada $(x,t)\in U\times [a,b]$ e a função $\frac{\partial f}{\partial x_i}:U\times [a,b]\longrightarrow \mathbb{R}$ assim definida é contínua.
		\end{enumerate}
		Então a função $\varphi: U\longrightarrow \mathbb{R}$ dada por
		$$\varphi(x)=\int_a^b f(x,t)dt\text{,}$$
		possui $i$-ésima derivada parcial em cada ponto $x\in U$, sendo
		$$\frac{\partial \varphi}{\partial x_i}(x)=\int_a^b \frac{\partial f}{\partial x_i}(x,t)dt\text{.}$$

		\begin{proof}
			Considere
			$$
			\frac{\varphi(x+se_i)-\varphi(x)}{s}
			=
			\int_a^b \frac{f(x+se_i, t)-f(x,t)}{s} dt\text{,}
			$$
			de onde subtraindo $\displaystyle \int_a^b \frac{\partial f}{\partial x_i}(x,t) dt$ de ambos os lados, tem-se
			\begin{equation}
			\label{eqn:cap_ap_leibniz:subtract_1}
			\frac{\varphi(x+se_i)-\varphi(x)}{s}
			- \int_a^b \frac{\partial f}{\partial x_i}(x,t) dt
			=
			\int_a^b \left [ 
				\frac{f(x+se_i, t)-f(x,t)}{s} 
				- \frac{\partial f}{\partial x_i}(x,t)
			\right ] dt
			\end{equation}
			
			Pelo Teorema do Valor Médio para funções reais, existe $\theta \in [0,1]$ de modo que
			$$
				\frac{f(x+se_i,t)-f(x,t)}{s}=\frac{\partial f}{\partial x_i}(x+\theta s e_i,t)\text{,}
			$$
			onde $\theta \in [0,1]$ garante que $\theta s$ esteja entre $]0, s[$, satisfazendo as condições do Teorema do Valor Médio. Assim, de \eqref{eqn:cap_ap_leibniz:subtract_1} tem-se
			%donde pode-se escrever \eqref{eqn:cap_ap_leibniz:subtract_1} como
			\begin{equation}
				\label{eqn:cap_ap_leibniz:tvm}
				\frac{\varphi(x+se_i)-\varphi(x)}{s}
				- \int_a^b \frac{\partial f}{\partial x_i}(x,t) dt
				=
				\int_a^b \left [
					\frac{\partial f}{\partial x_i}(x+\theta s e_i, t)-\frac{\partial f}{\partial x_i}(x,t)
				\right ] dt\text{.}
			\end{equation}
			
			Como $\dfrac{\partial f}{\partial x_i}$ é contínua e $[a,b]$ é compacto, pelo Teorema \ref{teorema:func_uniformemente}, para todo $\varepsilon > 0$, existe um $\delta > 0$, de modo que
			\begin{equation}
				\label{eqn:cap_ap_leibniz:compact_limit}
				|s|<\delta \Longrightarrow
				\left | 
					\frac{\partial f}{\partial x_i} (x+\theta s e_i, t) - \frac{\partial f}{\partial x_i}(x,t)
				\right | < \frac{\varepsilon}{b-a}
			\end{equation}
			seja qual for $t \in [a,b]$.
			
			Usando o fato de que $\displaystyle \Big |\int_a^b f(x)dx \Big | \leqslant \int_a^b |f(x)| dx$, obtêm-se
			$$
			\left |
				\int_a^b \left [
					\frac{\partial f}{\partial x_i}(x+\theta s e_i, t)-\frac{\partial f}{\partial x_i}(x,t)
				\right ] dt
			\right |
			\leqslant
			\int_a^b\left |
				\frac{\partial f}{\partial x_i}(x+\theta s e_i, t)-\frac{\partial f}{\partial x_i}(x,t)
			\right | dt\text{,}
			$$
			e, utilizando \eqref{eqn:cap_ap_leibniz:compact_limit}, tem-se a inequação
			$$
			\left |
				\int_a^b \left [
					\frac{\partial f}{\partial x_i}(x+\theta s e_i, t)-\frac{\partial f}{\partial x_i}(x,t)
				\right ] dt
			\right |
			<
			\int_a^b \frac{\varepsilon}{b-a} dt
			$$
			\begin{equation}
				\label{eqn:cap_ap_leibniz:epsilon_limit}
				\left |
					\int_a^b \left [
						\frac{\partial f}{\partial x_i}(x+\theta s e_i, t)-\frac{\partial f}{\partial x_i}(x,t)
					\right ] dt
				\right |
				< \varepsilon \text{.}
			\end{equation}
			
			De \eqref{eqn:cap_ap_leibniz:tvm} e \eqref{eqn:cap_ap_leibniz:epsilon_limit}, verifica-se que
			$$
				|s|<\delta \Longrightarrow
				\left |
					\frac{\varphi(x+se_i)-\varphi(x)}{s}
					- \int_a^b \frac{\partial f}{\partial x_i}(x,t) dt
				\right |
				< \varepsilon\text{,}
			$$
			que é, a definição formal do limite
			$$
				 \lim_{s\to 0} \frac{\varphi (x+se_i)-\varphi(x)}{s}= \int_a^b \frac{\partial f}{\partial x_i} (x, t)dt \text{,}
			$$
			ou seja,
			$$
				\frac{\partial \varphi}{\partial x_i}(x)=\int _a^b \frac{\partial f}{\partial x_i}(x,t)dt\text{.}
			$$
		\end{proof}
	\end{teorema}
	
	\begin{definicao}
		\label{def:cap_conceitos_analise:classe_ck}
		Seja o aberto $U\subset\mathbb{R}^n$. Uma função $f:U\longrightarrow\mathbb{R}$ é dita de classe $C^0$ quando é contínua. Diz-se, também, que $f:U\longrightarrow\mathbb{R}$ é de classe $C^1$ quando existem, em cada ponto $x\in U$, as derivadas parciais $\dfrac{\partial f}{\partial x_1}(x)$, $\dots$, $\dfrac{\partial f}{\partial x_n}(x)$ e, as $n$ funções $\dfrac{\partial f}{\partial x_i}:U\longrightarrow \mathbb{R}$, assim definidas, são contínuas. Mais geralmente, uma função $f:U\longrightarrow\mathbb{R}$ é dita de classe \index[remissivo]{Função de Classe $C^k$}$C^k$, onde $k>0$ é um inteiro, quando ela possuir derivadas parciais em todos os pontos de $U$ e as funções $\dfrac{\partial f}{\partial x_i}$, $\dots$, $\dfrac{\partial f}{\partial x_n}:U\longrightarrow \mathbb{R}$ forem de classe $C^{k-1}$.
	\end{definicao}
	
	A Definição \ref{def:cap_conceitos_analise:classe_ck} é equivalente a dizer que uma função $f:U\longrightarrow\mathbb{R}$, onde $U\subset\mathbb{R}^n$, é dita de classe $C^k$ se todas as suas derivadas parciais até a ordem $k$ existirem e, ainda, forem todas contínuas. Completando, $f$ será de classe $C^0$ caso seja contínua.
}

\chapter{ENCONTRANDO A MÁXIMA DEFLEXÃO DA VIGA ESTUDADA}
\label{apend:max_deflex}
{
	Durante o estudo do método de Rayleigh-Ritz no Exemplo \ref{ex:mrr_ex_livro}, no Capítulo \ref{cap:mrr}, faz-se necessário ter valores para comparação. Com esse objetivo, pode-se determinar a máxima deflexão da viga a partir da solução analítica $v(x)$ do problema, determinada no Exemplo \ref{ex:cond_contorno} da Seção \ref{sec:calcvar_exemplos} do Capítulo \ref{cap:calc_var}, a partir de \eqref{eqn:sol_funcional_analitico},
	\begin{equation}
	\label{eqn:max_deflex_func}
	v(x) = 
		\frac{q}{24EI} x^4
		-
		\frac{ql}{12EI} x^3
		+
		\frac{ql^3}{24EI} x
		\text{.}
	\end{equation}
	
	Derivando \eqref{eqn:max_deflex_func}, tem-se
	\begin{equation}
	\label{eqn:max_deflex_func_diff}
	v'(x) =
		\frac{4q}{24EI}x^3
		-
		\frac{3ql}{12EI}x^2
		+
		\frac{ql^3}{24EI}
		\text{.}
	\end{equation}
	
	Fazendo $v'(x)=0$ é possível determinar os pontos de máximo e mínimo da função, donde
	$$
		\frac{4q}{24EI}x^3
		-
		\frac{6ql}{24EI}x^2
		+
		\frac{ql^3}{24EI}
		= 0
	$$
	\begin{equation}
		\label{eqn:max_deflex_equation}
		4x^3 - 6lx^2 + l^3 = 0
		\text{.}
	\end{equation}
	
	A equação \eqref{eqn:max_deflex_equation} tem como uma de suas soluções o valor $x_1=\dfrac{l}{2}$, pois
	$$
		4\left (\frac{l}{2}\right )^3 - 6l\left ( \frac{l}{2}\right )^2+l^3=0
		\text{,}
	$$
	de onde, realizando uma divisão do polinômio de \eqref{eqn:max_deflex_equation} por $x-\dfrac{l}{2}$ é possível determinar os outros extremos. Deste modo,
	$$
		4x^3-6lx^2+l^3 = (x-\frac{l}{2})(4x^2-4lx-2l^2)=0
		\text{,}
	$$
	e, portanto, para a determinação dos outros extremos deve-se resolver a equação de segundo grau $4x^2-4lx-2l^2=0$, que resulta em $x_2=\dfrac{(1+\sqrt{3})}{2}l$ e $x_3=\dfrac{(1-\sqrt{3})}{2}l$.
	
	Fazendo o estudo de sinais de $v'(x)$ resulta que $x_1=\dfrac{l}{2}$ é ponto de máximo, enquanto que os demais são pontos de mínimo, logo, a máxima deflexão da viga acontece quando $x=\dfrac{l}{2}$.
	
	Calculando o valor da máxima deflexão,
	$$
		v\left (\frac{l}{2}\right )=
			\frac{q}{24EI} \left (
				\frac{l}{2}
			\right )^4
			-
			\frac{ql}{12EI} \left (
				\frac{l}{2}
			\right )^3
			+
			\frac{ql^3}{24EI}\left (
				\frac{l}{2}
			\right )
	$$
	\begin{equation}
	\label{eqn:max_deflex_resultado}
		v\left (\frac{l}{2}\right )=
			\frac{5ql^4}{384EI}
			\text{.}
	\end{equation}
}

\chapter{BREVE INTRODUÇÃO À LINGUAGEM \textit{PYTHON}}
\label{apend:python}
{
	Durante o trabalho, são utilizados trechos de códigos na linguagem \textit{Python}. Para auxiliar a introdução nesse universo, é apresentado aqui, uma breve explicação sobre sua instalação e execução de programas. Na última seção, é apresentado o código utilizado para a resolução de sistemas lineares na linguagem.

	\section{Instalando}
	
	A linguagem de programação \index[remissivo]{Python}\textit{Python} é distribuida gratuitamente e pode ser baixada no seu site\footnote{\url{https://www.python.org/}.}. É necessário ressaltar, também, que em distribuições \textit{Linux}, como o \textit{Linux Mint}, a linguagem geralmente já vem instalada por padrão. Devido a isso e, também, ao fato de que usuários de ambientes \textit{Linux} costumam ter conhecimentos avançados sobre instalação de programas, será explicado nessa seção apenas a instalação no sistema operacional \textit{Windows}.
	
	O executável da linguagem \textit{Python} pode ser baixado em seu site, na aba \textit{Downloads}, como pode ser visto na Figura \ref{fig:python_pagina}.
	
	\begin{figure}[h]
		\caption{Página de \textit{download} da linguagem \textit{Python}.}
		\centering
		\includegraphics[scale=0.4]{../figuras/python/python_download.png}
		\label{fig:python_pagina}
		\legend{\ABNTEXfontereduzida Fonte: Elaborada pelo autor, 2019.}
	\end{figure}
	
	Sua instalação é extremamente simples e rápida. Basta executar o instalador baixado da página da Figura \ref{fig:python_pagina}, marcar a opção \textit{"Add Python 3.8 to PATH"}, como na Figura \ref{fig:python_instalador} para facilitar a execução de códigos com a linguagem e clicar em \textit{Install Now}, isto é, instalar agora e esperar até que a instalação termine.
	
	\begin{figure}[h]
		\caption{Instalador da linguagem \textit{Python} no \textit{Windows}.}
		\centering
		\includegraphics[scale=0.6]{../figuras/python/python_install.png}
		\label{fig:python_instalador}
		\legend{\ABNTEXfontereduzida Fonte: Elaborada pelo autor, 2019.}
	\end{figure}
	
	Após a instalação da linguagem, é necessário instalar alguns pacotes utilizados aqui neste trabalho. Para tanto, é preciso executar o \textit{prompt} de comandos do \textit{Windows}, ou terminal em distribuições \textit{Linux}. No \textit{Windows}, basta digitar \textit{cmd} na barra de pesquisa do menu iniciar, como na Figura \ref{fig:python_barra_busca}.
	
	\begin{figure}[h]
		\caption{Barra de busca com o \textit{prompt} de comandos do \textit{Windows}.}
		\centering
		\includegraphics[scale=0.5]{../figuras/python/barra_busca.png}
		\label{fig:python_barra_busca}
		\legend{\ABNTEXfontereduzida Fonte: Elaborada pelo autor, 2019.}
	\end{figure}
	
	Com o \textit{prompt} de comandos aberto, deve-se executar o código \textit{pip install numpy} para instalar o pacote \textit{numpy}. Após a instalação, uma janela parecida com a Figura \ref{fig:python_pip_numpy} deve ser vista. Esse mesmo processo deve ser repetido com os comandos \textit{pip install sympy} para instalar o pacote \textit{sympy} e \text{pip install matplotlib} para instalar o pacote \textit{matplotlib}. Esses três pacotes são utilizados durante este trabalho.
	
	\begin{figure}[h]
		\caption{\textit{Prompt} de comandos após a instalação do pacote \textit{numpy}.}
		\centering
		\includegraphics[scale=0.6]{../figuras/python/python_pip_numpy.png}
		\label{fig:python_pip_numpy}
		\legend{\ABNTEXfontereduzida Fonte: Elaborada pelo autor, 2019.}
	\end{figure}
	
	\section{Executando programas}
	
	Para executar programas, ou \textit{scripts}, na linguagem \textit{Python}, existem diversas formas, sendo a mais convencional delas executar via o \textit{prompt} de comandos do \textit{Windows} ou no terminal do \textit{Linux}. No \textit{Windows} pode-se utilizar o ambiente de desenvolvimento que é instalado junto a linguagem, chamado de IDLE. Ao abri-lo, deve-se ir no menu \textit{File} e, então, em \textit{New File} para criar um novo arquivo. O código deve ser escrito nesse novo arquivo e salvo. Para executar este código basta, então, ir no menu \textit{Run} e, depois, em \textit{Run Module}, como na Figura \ref{fig:python_runmodule}.
	
	\begin{figure}[h]
		\caption{Janela do IDLE com o menu \textit{Run} aberto.}
		\centering
		\includegraphics[scale=0.6]{../figuras/python/python_runmodule.png}
		\label{fig:python_runmodule}
		\legend{\ABNTEXfontereduzida Fonte: Elaborada pelo autor, 2019.}
	\end{figure}
	
	A segunda forma, indicada para usuários que detenham um nível de conhecimento mais alto sobre sistemas operacionais, é executar, no \textit{prompt} de comandos ou no terminal a linha \textit{python arquivo.py}, onde \textit{arquivo.py} representa o caminho para o arquivo no sistema. Por exemplo, como os códigos deste trabalho foram desenvolvidos em um ambiente \textit{Linux}, todos os códigos foram executados deste modo.
	
	\section{Principais operações}
	
	Para facilitar o entendimento dos códigos ao longo do trabalho, é apresentada uma lista com algumas das principais operações aritméticas na linguagem \textit{Python} na Tabela \ref{table:principais_operacoes}.
	
	\begin{table}[h]
		\caption{Principais operações na linguagem \textit{Python}}
		\ABNTEXfontereduzida
		\centering
		\begin{tabular}{p{0.3\textwidth}p{0.3\textwidth}}
			\toprule
			\textbf{Operação} & \textbf{Descrição}\\
			\midrule
			\ABNTEXfontereduzida
			\textit{x + y} & Soma de $x$ e $y$\\
			\textit{x - y} & Subtração de $x$ por $y$\\
			\textit{x * y} & Produto de $x$ por $y$\\
			\textit{x / y} & Divisão de $x$ por $y$\\
			\textit{x // y} & Parte inteira da divisão de $x$ por $y$\\
			\textit{x \% y} & O resto da divisão de $x$ por $y$\\
			\textit{x ** y} & $x$ elevado a potência $y$\\
			\bottomrule
		\end{tabular}\\
		{\vspace{5pt}\ABNTEXfontereduzida Fonte: Elaborada pelo autor, 2019.}
		\label{table:principais_operacoes}
	\end{table}
	
	\section{Resolução de sistemas lineares}
	\label{sec:python_solve_linsys}
	
	O sistema linear com matriz aumentada \eqref{eqn:cap_metodo_ray_ritz:matriz_sistema} pode ser facilmente resolvido utilizando métodos trabalhados em Álgebra Linear, como, por exemplo, o método de Gauss-Jordan, de forma manual. Outra forma de se resolver o sistema é fazendo o uso da linguagem de programação \textit{Python}, através do comando \textit{linsolve} que utiliza o \index[remissivo]{Método de Gauss-Jordan}método de Gauss-Jordan.
	
	Deste modo, seja, o sistema com matriz aumentada \eqref{eqn:cap_metodo_ray_ritz:matriz_sistema}
	\begin{equation}
		\label{eqn:cap_ap_sis_lin:matriz_sistema}
		\begin{amatrix}{3}
			2 & 3l  & 4l^2 				 & C \\
			1 & 2l  & 3l^2				 & \frac{1}{2}C \\
			8 & 18l & \frac{144}{5} l^2 & D
		\end{amatrix}
		\text{,}
	\end{equation}
	onde 
	\begin{equation}
		\label{eqn:cap_ap_sis_lin:aux_var_C}
		C=-\frac{ql^2}{12EI}
		\text{,}
	\end{equation}
	e
	\begin{equation}
		\label{eqn:cap_ap_sis_lin:aux_var_D}
		D=-\frac{3ql^2}{10EI}
		\text{.}
	\end{equation}
	
	Para a resolução do sistema usando \textit{Python} é necessário, primeiro, importar alguns componentes da biblioteca SymPy:
	\begin{lstlisting}[style=Python]
from sympy import symbols, Matrix
from sympy.solvers import linsolve
	\end{lstlisting}
	
	Serão importados os componentes \textit{symbols} para permitir a definição de símbolos matemáticos, \textit{Matrix} para a manipulação de matrizes e, finalmente, \textit{linsolve} para a resolução de sistemas lineares.
	
	Para a definição do sistema, utilizaremos os mesmos símbolos, $l$, $C$, e $D$, que são definidos, dentro da linguagem, utilizando o comando \textit{symbols} importado:
	\begin{lstlisting}[style=Python]
l, C, D = symbols('l C D')
	\end{lstlisting}
	
	A matriz aumentada é definida utilizando o componente \textit{Matrix} importado. Cada uma de suas linhas é escrita como um Array contendo os elementos das colunas. A matriz é escrita, então, como um Array de linhas.
	\begin{lstlisting}[style=Python]
A = Matrix([
    [2, 3 * l ,  4 * l**2      ,  C  ],
    [1, 2 * l ,  3 * l**2      ,  C/2],
    [8, 18 * l,  144 / 5 * l**2,  D  ]
])
	\end{lstlisting}
	
	A resolução do sistema é feita pelo método \textit{linsolve} já importado. O método \textit{linsolve} da linguagem \textit{Python} utiliza o método de Gauss-Jordan para a resolução de sistemas lineares \cite{SymPy}. Primeiro, definimos três novos símbolos, $a_1$, $a_2$ e $a_3$ que são as incógnitas do sistema e então, executamos o método passando como argumento a matriz $A$ definida e os símbolos.
	\begin{lstlisting}[style=Python]
a2, a3, a4 = symbols("a2 a3 a4")
sol, = linsolve(A, [a2, a3, a4])
print(sol)
	\end{lstlisting}

	\begin{figure}[h]
		\caption{Execução do código para a resolução do sistema linear.}
		\centering
		\includegraphics[scale=2]{../figuras/code/code_solve_sis_linear.png}
		\label{fig:code_solve_sis_linear}
		\legend{\ABNTEXfontereduzida Fonte: Elaborada pelo autor, 2019.}
	\end{figure}
	
	O comando \textit{print(sol)} exibe a solução do sistema linear, como um Array (Veja Figura \ref{fig:code_solve_sis_linear}). O primeiro valor do Array corresponde a incógnita $a_2$, o segundo valor a $a_3$ e o último valor a $a_4$. Assim, $a_2=-4.5C+1.25D$, $a_3=\dfrac{1}{l}(10C-2.5D)$ e $a_4=\dfrac{1}{l^2}(-5C+1.25D)$. Pode-se converter os números decimais para frações obtendo
	\begin{equation}
		\label{eqn:cap_ap_sis_lin:result_a2}
		a_2=\frac{5}{4}D-\frac{9}{2}C
		\text{,}
	\end{equation}
	\begin{equation}
		\label{eqn:cap_ap_sis_lin:result_a3}
		a_3=\frac{1}{l}\left (
			10C - \frac{5}{2} D
		\right ) \text{,}
	\end{equation}
	\begin{equation}
		\label{eqn:cap_ap_sis_lin:result_a4}
		a_4=\frac{1}{l^2}\left (
			\frac{5}{4}D-5C
		\right ) \text{.}
	\end{equation}
	
	Substituindo $C$ e $D$, de \eqref{eqn:cap_ap_sis_lin:aux_var_C} e \eqref{eqn:cap_ap_sis_lin:aux_var_D}, em \eqref{eqn:cap_ap_sis_lin:result_a2}, \eqref{eqn:cap_ap_sis_lin:result_a3} e \eqref{eqn:cap_ap_sis_lin:result_a4} e simplificando os valores obtem-se a solução do sistema
	$$
		a_2 = 0\text{,}
	$$
	$$
		a_3 = -\frac{ql}{12EI}\text{,}
	$$
	$$
		a_4 = \frac{q}{24EI}\text{.}
	$$

	O código completo utilizado para a resolução do sistema linear com matriz aumentada \eqref{eqn:cap_ap_sis_lin:matriz_sistema} é apresentado em Código \ref{py_code_solve_sys_linear}.
		
	\begin{lstlisting}[style=Python, xleftmargin=2em, numbers=left, caption={Resolução de sistemas lineares em \textit{Python}}, captionpos=t, label=py_code_solve_sys_linear]
from sympy import symbols, Matrix
from sympy.solvers import linsolve

l, C, D = symbols('l C D')

A = Matrix([
    [2, 3 * l ,  4 * l**2      ,  C  ],
    [1, 2 * l ,  3 * l**2      ,  C/2],
    [8, 18 * l,  144 / 5 * l**2,  D  ]
])

a2, a3, a4 = symbols("a2 a3 a4")
sol, = linsolve(A, [a2, a3, a4])

print(sol)
	\end{lstlisting}
	\codigofonte
}

\end{apendicesenv}
% ---

%---------------------------------------------------------------------
% INDICE REMISSIVO
%---------------------------------------------------------------------
\phantompart
\printindex[remissivo]
%---------------------------------------------------------------------

\end{document}
